{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/javascript/vendor.js","vendor.js","node_modules/underscore/underscore.js","mithril"],"names":["require","e","t","n","r","s","o","u","a","i","f","Error","code","l","exports","call","length",1,"module","mithril","underscore",2,"createReduce","dir","iterator","obj","iteratee","memo","keys","index","currentKey","context","optimizeCb","isArrayLike","_","arguments","createPredicateIndexFinder","array","predicate","cb","getLength","createIndexFinder","predicateFind","sortedIndex","item","idx","Math","max","min","slice","isNaN","collectNonEnumProps","nonEnumIdx","nonEnumerableProps","constructor","proto","isFunction","prototype","ObjProto","prop","has","contains","push","root","this","previousUnderscore","ArrayProto","Array","Object","FuncProto","Function","toString","hasOwnProperty","nativeIsArray","isArray","nativeKeys","nativeBind","bind","nativeCreate","create","Ctor","_wrapped","VERSION","func","argCount","value","other","collection","accumulator","apply","identity","isObject","matcher","property","Infinity","createAssigner","keysFunc","undefinedOnly","source","key","baseCreate","result","MAX_ARRAY_INDEX","pow","each","forEach","map","collect","results","reduce","foldl","inject","reduceRight","foldr","find","detect","findIndex","findKey","filter","select","list","reject","negate","every","all","some","any","includes","include","fromIndex","guard","values","indexOf","invoke","method","args","isFunc","pluck","where","attrs","findWhere","computed","lastComputed","shuffle","rand","set","shuffled","random","sample","sortBy","criteria","sort","left","right","b","group","behavior","groupBy","indexBy","countBy","toArray","size","partition","pass","fail","first","head","take","initial","last","rest","tail","drop","compact","flatten","input","shallow","strict","startIndex","output","isArguments","j","len","without","difference","uniq","unique","isSorted","isBoolean","seen","union","intersection","argsLength","zip","unzip","object","findLastIndex","low","high","mid","floor","lastIndexOf","range","start","stop","step","ceil","executeBound","sourceFunc","boundFunc","callingContext","self","TypeError","bound","concat","partial","boundArgs","position","bindAll","memoize","hasher","cache","address","delay","wait","setTimeout","defer","throttle","options","timeout","previous","later","leading","now","remaining","clearTimeout","trailing","debounce","immediate","timestamp","callNow","wrap","wrapper","compose","after","times","before","once","hasEnumBug","propertyIsEnumerable","allKeys","mapObject","pairs","invert","functions","methods","names","extend","extendOwn","assign","pick","oiteratee","omit","String","defaults","props","clone","tap","interceptor","isMatch","eq","aStack","bStack","className","areArrays","aCtor","bCtor","pop","isEqual","isEmpty","isString","isElement","nodeType","type","name","Int8Array","isFinite","parseFloat","isNumber","isNull","isUndefined","noConflict","constant","noop","propertyOf","matches","accum","Date","getTime","escapeMap","&","<",">","\"","'","`","unescapeMap","createEscaper","escaper","match","join","testRegexp","RegExp","replaceRegexp","string","test","replace","escape","unescape","fallback","idCounter","uniqueId","prefix","id","templateSettings","evaluate","interpolate","noMatch","escapes","\\","\r","\n"," "," ","escapeChar","template","text","settings","oldSettings","offset","variable","render","data","argument","chain","instance","_chain","mixin","valueOf","toJSON","define","amd","global","factory","m","window","undefined","initialize","mock","$document","document","$location","location","$cancelAnimationFrame","cancelAnimationFrame","$requestAnimationFrame","requestAnimationFrame","parseTagAttrs","cell","tag","classes","parser","exec","pair","getVirtualChildren","hasAttrs","children","assignAttrs","target","classAttr","attrName","hasOwn","parameterize","forKeys","dataToString","injectTextNode","parentElement","insertNode","nodeValue","node","insertBefore","childNodes","handleKeysDiffer","existing","cached","action","MOVE","from","element","nodes","createElement","INSERTION","actions","changes","sortChanges","newCached","change","DELETION","clear","splice","dummy","changeElement","maybeChanged","diffKeys","keysDiffer","cachedCell","diffArray","parentNode","buildArrayKeys","guid","isDifferentEnough","dataAttrKeys","redraw","strategy","configContext","retain","maybeRecreateObject","onunload","controllers","controller","preventDefault","getObjectNamespace","namespace","xmlns","unloadCachedControllers","views","$old","pendingRequests","scheduleConfigsToBeCalled","configs","isNew","config","buildUpdatedNode","editable","hasKeys","setAttributes","build","contenteditable","intact","handleNonexistentNodes","$trusted","injectHTML","createTextNode","nodeName","voidElements","reattachNodes","parentTag","activeElement","innerHTML","trim","handleTextNode","shouldReattach","getSubArrayCount","buildArray","subArrayCount","shouldMaintainIdentities","cacheCount","makeCache","parentIndex","parentCache","end","constructNode","is","createElementNS","constructAttrs","constructChildren","reconstructCached","getController","view","cachedControllers","controllerIndex","updateLists","unloaders","handler","checkView","forcing","subtree","markViews","$original","buildObject","copyStyleAttrs","dataAttr","cachedAttr","rule","style","setSingleAttr","autoredraw","setAttributeNS","setAttribute","shouldUseSetAttribute","trySetAttr","cachedAttrs","message","dataAttrs","removeChild","unload","appendTextFragment","appendChild","createRange","createContextualFragment","insertAdjacentHTML","nextSibling","placeholder","callback","event","startComputation","endFirstComputation","getCellCacheKey","nodeCache","gettersetter","store","component","ctrl","currentArgs","checkPrevented","isPrevented","roots","currentComponent","topComponent","components","removeRootElement","reset","computePreRedrawHook","computePostRedrawHook","lastRedrawId","lastRedrawCallTime","endComputation","normalizeRoute","route","modes","mode","routeByValue","router","path","routeParams","queryStart","parseQueryString","substr","mount","decodeURIComponent","routeUnobtrusive","ctrlKey","metaKey","shiftKey","which","returnValue","currentTarget","srcElement","search","setScroll","hash","scrollTo","buildQueryString","duplicates","str","encodeURIComponent","charAt","split","params","cacheKey","cellCache","propify","promise","initialValue","then","resolve","Deferred","onSuccess","onFailure","finish","state","REJECTED","next","deferred","RESOLVED","promiseValue","thennable","success","failure","notThennable","count","onerror","fire","REJECTING","RESOLVING","handleJsonp","callbackKey","round","script","resp","onload","responseText","status","JSON","stringify","error","src","url","body","createXhr","xhr","XMLHttpRequest","open","user","password","onreadystatechange","readyState","serialize","setRequestHeader","deserialize","parse","maybeXhr","FormData","send","ajax","dataType","toLowerCase","bindData","querystring","parameterizeUrl","token","version","AREA","BASE","BR","COL","COMMAND","EMBED","HR","IMG","INPUT","KEYGEN","LINK","META","PARAM","SOURCE","TRACK","WBR","deps","html","form","width","height","documentNode","documentElement","replaceChild","forceRecreation","isDocumentRoot","trust","FRAME_BUDGET","unloader","redrawing","force","withAttr","withAttrCallback","callbackThis","_this","getAttribute","currentRoute","pathname","redirect","isDefaultRoute","arg1","arg2","vdom","listener","addEventListener","attachEvent","base","href","removeEventListener","detachEvent","oldRoute","queryIndex","currentPath","replaceHistory","history","pushState","title","param","sync","synchronizer","pos","resolved","outstanding","arg","request","background","extract","isJSONP","jsonp","toUpperCase","ev","response","unwrapSuccess","res","unwrapError"],"mappings":"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","file":"vendor.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","require('underscore');\nrequire('mithril');\n","require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nrequire('underscore');\nrequire('mithril');\n\n},{\"mithril\":\"mithril\",\"underscore\":2}],2:[function(require,module,exports){\n//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.8.3';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result — either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n  _.iteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, undefinedOnly) {\n    return function(obj) {\n      var length = arguments.length;\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var property = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = property('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  function createReduce(dir) {\n    // Optimized iterator function as using arguments.length\n    // in the main function will deoptimize the, see #1991.\n    function iterator(obj, iteratee, memo, keys, index, length) {\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    }\n\n    return function(obj, iteratee, memo, context) {\n      iteratee = optimizeCb(iteratee, context, 4);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      // Determine the initial value if none is provided.\n      if (arguments.length < 3) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      return iterator(obj, iteratee, memo, keys, index, length);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var key;\n    if (isArrayLike(obj)) {\n      key = _.findIndex(obj, predicate, context);\n    } else {\n      key = _.findKey(obj, predicate, context);\n    }\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var set = isArrayLike(obj) ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, startIndex) {\n    var output = [], idx = 0;\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        //flatten current level of array or arguments object\n        if (!shallow) value = flatten(value, shallow, strict);\n        var j = 0, len = value.length;\n        output.length += len;\n        while (j < len) {\n          output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(arguments, true, true, 1);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    return _.unzip(arguments);\n  };\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a predicate test\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n            i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var args = slice.call(arguments, 2);\n    var bound = function() {\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object\n  // In contrast to _.map it returns an object\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys =  _.keys(obj),\n          length = keys.length,\n          results = {},\n          currentKey;\n      for (var index = 0; index < length; index++) {\n        currentKey = keys[index];\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(object, oiteratee, context) {\n    var result = {}, obj = object, iteratee, keys;\n    if (obj == null) return result;\n    if (_.isFunction(oiteratee)) {\n      keys = _.allKeys(obj);\n      iteratee = optimizeCb(oiteratee, context);\n    } else {\n      keys = flatten(arguments, false, false, 1);\n      iteratee = function(value, key, obj) { return key in obj; };\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(flatten(arguments, false, false, 1), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), and in Safari 8 (#1929).\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = property;\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    return obj == null ? function(){} : function(key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property, fallback) {\n    var value = object == null ? void 0 : object[property];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return '' + this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this));\n\n},{}],\"mithril\":[function(require,module,exports){\n;(function (global, factory) { // eslint-disable-line\r\n\t\"use strict\"\r\n\t/* eslint-disable no-undef */\r\n\tvar m = factory(global)\r\n\tif (typeof module === \"object\" && module != null && module.exports) {\r\n\t\tmodule.exports = m\r\n\t} else if (typeof define === \"function\" && define.amd) {\r\n\t\tdefine(function () { return m })\r\n\t} else {\r\n\t\tglobal.m = m\r\n\t}\r\n\t/* eslint-enable no-undef */\r\n})(typeof window !== \"undefined\" ? window : {}, function (global, undefined) { // eslint-disable-line\r\n\t\"use strict\"\r\n\r\n\tm.version = function () {\r\n\t\treturn \"v0.2.3\"\r\n\t}\r\n\r\n\tvar hasOwn = {}.hasOwnProperty\r\n\tvar type = {}.toString\r\n\r\n\tfunction isFunction(object) {\r\n\t\treturn typeof object === \"function\"\r\n\t}\r\n\r\n\tfunction isObject(object) {\r\n\t\treturn type.call(object) === \"[object Object]\"\r\n\t}\r\n\r\n\tfunction isString(object) {\r\n\t\treturn type.call(object) === \"[object String]\"\r\n\t}\r\n\r\n\tvar isArray = Array.isArray || function (object) {\r\n\t\treturn type.call(object) === \"[object Array]\"\r\n\t}\r\n\r\n\tfunction noop() {}\r\n\r\n\tvar voidElements = {\r\n\t\tAREA: 1,\r\n\t\tBASE: 1,\r\n\t\tBR: 1,\r\n\t\tCOL: 1,\r\n\t\tCOMMAND: 1,\r\n\t\tEMBED: 1,\r\n\t\tHR: 1,\r\n\t\tIMG: 1,\r\n\t\tINPUT: 1,\r\n\t\tKEYGEN: 1,\r\n\t\tLINK: 1,\r\n\t\tMETA: 1,\r\n\t\tPARAM: 1,\r\n\t\tSOURCE: 1,\r\n\t\tTRACK: 1,\r\n\t\tWBR: 1\r\n\t}\r\n\r\n\t// caching commonly used variables\r\n\tvar $document, $location, $requestAnimationFrame, $cancelAnimationFrame\r\n\r\n\t// self invoking function needed because of the way mocks work\r\n\tfunction initialize(mock) {\r\n\t\t$document = mock.document\r\n\t\t$location = mock.location\r\n\t\t$cancelAnimationFrame = mock.cancelAnimationFrame || mock.clearTimeout\r\n\t\t$requestAnimationFrame = mock.requestAnimationFrame || mock.setTimeout\r\n\t}\r\n\r\n\t// testing API\r\n\tm.deps = function (mock) {\r\n\t\tinitialize(global = mock || window)\r\n\t\treturn global\r\n\t}\r\n\r\n\tm.deps(global)\r\n\r\n\t/**\r\n\t * @typedef {String} Tag\r\n\t * A string that looks like -> div.classname#id[param=one][param2=two]\r\n\t * Which describes a DOM node\r\n\t */\r\n\r\n\tfunction parseTagAttrs(cell, tag) {\r\n\t\tvar classes = []\r\n\t\tvar parser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[.+?\\])/g\r\n\t\tvar match\r\n\r\n\t\twhile ((match = parser.exec(tag))) {\r\n\t\t\tif (match[1] === \"\" && match[2]) {\r\n\t\t\t\tcell.tag = match[2]\r\n\t\t\t} else if (match[1] === \"#\") {\r\n\t\t\t\tcell.attrs.id = match[2]\r\n\t\t\t} else if (match[1] === \".\") {\r\n\t\t\t\tclasses.push(match[2])\r\n\t\t\t} else if (match[3][0] === \"[\") {\r\n\t\t\t\tvar pair = /\\[(.+?)(?:=(\"|'|)(.*?)\\2)?\\]/.exec(match[3])\r\n\t\t\t\tcell.attrs[pair[1]] = pair[3] || (pair[2] ? \"\" : true)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn classes\r\n\t}\r\n\r\n\tfunction getVirtualChildren(args, hasAttrs) {\r\n\t\tvar children = hasAttrs ? args.slice(1) : args\r\n\r\n\t\tif (children.length === 1 && isArray(children[0])) {\r\n\t\t\treturn children[0]\r\n\t\t} else {\r\n\t\t\treturn children\r\n\t\t}\r\n\t}\r\n\r\n\tfunction assignAttrs(target, attrs, classes) {\r\n\t\tvar classAttr = \"class\" in attrs ? \"class\" : \"className\"\r\n\r\n\t\tfor (var attrName in attrs) {\r\n\t\t\tif (hasOwn.call(attrs, attrName)) {\r\n\t\t\t\tif (attrName === classAttr &&\r\n\t\t\t\t\t\tattrs[attrName] != null &&\r\n\t\t\t\t\t\tattrs[attrName] !== \"\") {\r\n\t\t\t\t\tclasses.push(attrs[attrName])\r\n\t\t\t\t\t// create key in correct iteration order\r\n\t\t\t\t\ttarget[attrName] = \"\"\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttarget[attrName] = attrs[attrName]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (classes.length) target[classAttr] = classes.join(\" \")\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Tag} The DOM node tag\r\n\t * @param {Object=[]} optional key-value pairs to be mapped to DOM attrs\r\n\t * @param {...mNode=[]} Zero or more Mithril child nodes. Can be an array,\r\n\t *                      or splat (optional)\r\n\t */\r\n\tfunction m(tag, pairs) {\r\n\t\tvar args = [].slice.call(arguments, 1)\r\n\r\n\t\tif (isObject(tag)) return parameterize(tag, args)\r\n\r\n\t\tif (!isString(tag)) {\r\n\t\t\tthrow new Error(\"selector in m(selector, attrs, children) should \" +\r\n\t\t\t\t\"be a string\")\r\n\t\t}\r\n\r\n\t\tvar hasAttrs = pairs != null && isObject(pairs) &&\r\n\t\t\t!(\"tag\" in pairs || \"view\" in pairs || \"subtree\" in pairs)\r\n\r\n\t\tvar attrs = hasAttrs ? pairs : {}\r\n\t\tvar cell = {\r\n\t\t\ttag: \"div\",\r\n\t\t\tattrs: {},\r\n\t\t\tchildren: getVirtualChildren(args, hasAttrs)\r\n\t\t}\r\n\r\n\t\tassignAttrs(cell.attrs, attrs, parseTagAttrs(cell, tag))\r\n\t\treturn cell\r\n\t}\r\n\r\n\tfunction forEach(list, f) {\r\n\t\tfor (var i = 0; i < list.length && !f(list[i], i++);) {\r\n\t\t\t// function called in condition\r\n\t\t}\r\n\t}\r\n\r\n\tfunction forKeys(list, f) {\r\n\t\tforEach(list, function (attrs, i) {\r\n\t\t\treturn (attrs = attrs && attrs.attrs) &&\r\n\t\t\t\tattrs.key != null &&\r\n\t\t\t\tf(attrs, i)\r\n\t\t})\r\n\t}\r\n\t// This function was causing deopts in Chrome.\r\n\tfunction dataToString(data) {\r\n\t\t// data.toString() might throw or return null if data is the return\r\n\t\t// value of Console.log in some versions of Firefox (behavior depends on\r\n\t\t// version)\r\n\t\ttry {\r\n\t\t\tif (data != null && data.toString() != null) return data\r\n\t\t} catch (e) {\r\n\t\t\t// silently ignore errors\r\n\t\t}\r\n\t\treturn \"\"\r\n\t}\r\n\r\n\t// This function was causing deopts in Chrome.\r\n\tfunction injectTextNode(parentElement, first, index, data) {\r\n\t\ttry {\r\n\t\t\tinsertNode(parentElement, first, index)\r\n\t\t\tfirst.nodeValue = data\r\n\t\t} catch (e) {\r\n\t\t\t// IE erroneously throws error when appending an empty text node\r\n\t\t\t// after a null\r\n\t\t}\r\n\t}\r\n\r\n\tfunction flatten(list) {\r\n\t\t// recursively flatten array\r\n\t\tfor (var i = 0; i < list.length; i++) {\r\n\t\t\tif (isArray(list[i])) {\r\n\t\t\t\tlist = list.concat.apply([], list)\r\n\t\t\t\t// check current index again and flatten until there are no more\r\n\t\t\t\t// nested arrays at that index\r\n\t\t\t\ti--\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn list\r\n\t}\r\n\r\n\tfunction insertNode(parentElement, node, index) {\r\n\t\tparentElement.insertBefore(node,\r\n\t\t\tparentElement.childNodes[index] || null)\r\n\t}\r\n\r\n\tvar DELETION = 1\r\n\tvar INSERTION = 2\r\n\tvar MOVE = 3\r\n\r\n\tfunction handleKeysDiffer(data, existing, cached, parentElement) {\r\n\t\tforKeys(data, function (key, i) {\r\n\t\t\texisting[key = key.key] = existing[key] ? {\r\n\t\t\t\taction: MOVE,\r\n\t\t\t\tindex: i,\r\n\t\t\t\tfrom: existing[key].index,\r\n\t\t\t\telement: cached.nodes[existing[key].index] ||\r\n\t\t\t\t\t$document.createElement(\"div\")\r\n\t\t\t} : {action: INSERTION, index: i}\r\n\t\t})\r\n\r\n\t\tvar actions = []\r\n\t\tfor (var prop in existing) if (hasOwn.call(existing, prop)) {\r\n\t\t\tactions.push(existing[prop])\r\n\t\t}\r\n\r\n\t\tvar changes = actions.sort(sortChanges)\r\n\t\tvar newCached = new Array(cached.length)\r\n\r\n\t\tnewCached.nodes = cached.nodes.slice()\r\n\r\n\t\tforEach(changes, function (change) {\r\n\t\t\tvar index = change.index\r\n\t\t\tif (change.action === DELETION) {\r\n\t\t\t\tclear(cached[index].nodes, cached[index])\r\n\t\t\t\tnewCached.splice(index, 1)\r\n\t\t\t}\r\n\t\t\tif (change.action === INSERTION) {\r\n\t\t\t\tvar dummy = $document.createElement(\"div\")\r\n\t\t\t\tdummy.key = data[index].attrs.key\r\n\t\t\t\tinsertNode(parentElement, dummy, index)\r\n\t\t\t\tnewCached.splice(index, 0, {\r\n\t\t\t\t\tattrs: {key: data[index].attrs.key},\r\n\t\t\t\t\tnodes: [dummy]\r\n\t\t\t\t})\r\n\t\t\t\tnewCached.nodes[index] = dummy\r\n\t\t\t}\r\n\r\n\t\t\tif (change.action === MOVE) {\r\n\t\t\t\tvar changeElement = change.element\r\n\t\t\t\tvar maybeChanged = parentElement.childNodes[index]\r\n\t\t\t\tif (maybeChanged !== changeElement && changeElement !== null) {\r\n\t\t\t\t\tparentElement.insertBefore(changeElement,\r\n\t\t\t\t\t\tmaybeChanged || null)\r\n\t\t\t\t}\r\n\t\t\t\tnewCached[index] = cached[change.from]\r\n\t\t\t\tnewCached.nodes[index] = changeElement\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\treturn newCached\r\n\t}\r\n\r\n\tfunction diffKeys(data, cached, existing, parentElement) {\r\n\t\tvar keysDiffer = data.length !== cached.length\r\n\r\n\t\tif (!keysDiffer) {\r\n\t\t\tforKeys(data, function (attrs, i) {\r\n\t\t\t\tvar cachedCell = cached[i]\r\n\t\t\t\treturn keysDiffer = cachedCell &&\r\n\t\t\t\t\tcachedCell.attrs &&\r\n\t\t\t\t\tcachedCell.attrs.key !== attrs.key\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tif (keysDiffer) {\r\n\t\t\treturn handleKeysDiffer(data, existing, cached, parentElement)\r\n\t\t} else {\r\n\t\t\treturn cached\r\n\t\t}\r\n\t}\r\n\r\n\tfunction diffArray(data, cached, nodes) {\r\n\t\t// diff the array itself\r\n\r\n\t\t// update the list of DOM nodes by collecting the nodes from each item\r\n\t\tforEach(data, function (_, i) {\r\n\t\t\tif (cached[i] != null) nodes.push.apply(nodes, cached[i].nodes)\r\n\t\t})\r\n\t\t// remove items from the end of the array if the new array is shorter\r\n\t\t// than the old one. if errors ever happen here, the issue is most\r\n\t\t// likely a bug in the construction of the `cached` data structure\r\n\t\t// somewhere earlier in the program\r\n\t\tforEach(cached.nodes, function (node, i) {\r\n\t\t\tif (node.parentNode != null && nodes.indexOf(node) < 0) {\r\n\t\t\t\tclear([node], [cached[i]])\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tif (data.length < cached.length) cached.length = data.length\r\n\t\tcached.nodes = nodes\r\n\t}\r\n\r\n\tfunction buildArrayKeys(data) {\r\n\t\tvar guid = 0\r\n\t\tforKeys(data, function () {\r\n\t\t\tforEach(data, function (attrs) {\r\n\t\t\t\tif ((attrs = attrs && attrs.attrs) && attrs.key == null) {\r\n\t\t\t\t\tattrs.key = \"__mithril__\" + guid++\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\treturn 1\r\n\t\t})\r\n\t}\r\n\r\n\tfunction isDifferentEnough(data, cached, dataAttrKeys) {\r\n\t\tif (data.tag !== cached.tag) return true\r\n\r\n\t\tif (dataAttrKeys.sort().join() !==\r\n\t\t\t\tObject.keys(cached.attrs).sort().join()) {\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\tif (data.attrs.id !== cached.attrs.id) {\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\tif (data.attrs.key !== cached.attrs.key) {\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\tif (m.redraw.strategy() === \"all\") {\r\n\t\t\treturn !cached.configContext || cached.configContext.retain !== true\r\n\t\t}\r\n\r\n\t\tif (m.redraw.strategy() === \"diff\") {\r\n\t\t\treturn cached.configContext && cached.configContext.retain === false\r\n\t\t}\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\tfunction maybeRecreateObject(data, cached, dataAttrKeys) {\r\n\t\t// if an element is different enough from the one in cache, recreate it\r\n\t\tif (isDifferentEnough(data, cached, dataAttrKeys)) {\r\n\t\t\tif (cached.nodes.length) clear(cached.nodes)\r\n\r\n\t\t\tif (cached.configContext &&\r\n\t\t\t\t\tisFunction(cached.configContext.onunload)) {\r\n\t\t\t\tcached.configContext.onunload()\r\n\t\t\t}\r\n\r\n\t\t\tif (cached.controllers) {\r\n\t\t\t\tforEach(cached.controllers, function (controller) {\r\n\t\t\t\t\tif (controller.onunload) controller.onunload({preventDefault: noop});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getObjectNamespace(data, namespace) {\r\n\t\tif (data.attrs.xmlns) return data.attrs.xmlns\r\n\t\tif (data.tag === \"svg\") return \"http://www.w3.org/2000/svg\"\r\n\t\tif (data.tag === \"math\") return \"http://www.w3.org/1998/Math/MathML\"\r\n\t\treturn namespace\r\n\t}\r\n\r\n\tvar pendingRequests = 0\r\n\tm.startComputation = function () { pendingRequests++ }\r\n\tm.endComputation = function () {\r\n\t\tif (pendingRequests > 1) {\r\n\t\t\tpendingRequests--\r\n\t\t} else {\r\n\t\t\tpendingRequests = 0\r\n\t\t\tm.redraw()\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unloadCachedControllers(cached, views, controllers) {\r\n\t\tif (controllers.length) {\r\n\t\t\tcached.views = views\r\n\t\t\tcached.controllers = controllers\r\n\t\t\tforEach(controllers, function (controller) {\r\n\t\t\t\tif (controller.onunload && controller.onunload.$old) {\r\n\t\t\t\t\tcontroller.onunload = controller.onunload.$old\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (pendingRequests && controller.onunload) {\r\n\t\t\t\t\tvar onunload = controller.onunload\r\n\t\t\t\t\tcontroller.onunload = noop\r\n\t\t\t\t\tcontroller.onunload.$old = onunload\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tfunction scheduleConfigsToBeCalled(configs, data, node, isNew, cached) {\r\n\t\t// schedule configs to be called. They are called after `build` finishes\r\n\t\t// running\r\n\t\tif (isFunction(data.attrs.config)) {\r\n\t\t\tvar context = cached.configContext = cached.configContext || {}\r\n\r\n\t\t\t// bind\r\n\t\t\tconfigs.push(function () {\r\n\t\t\t\treturn data.attrs.config.call(data, node, !isNew, context,\r\n\t\t\t\t\tcached)\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tfunction buildUpdatedNode(\r\n\t\tcached,\r\n\t\tdata,\r\n\t\teditable,\r\n\t\thasKeys,\r\n\t\tnamespace,\r\n\t\tviews,\r\n\t\tconfigs,\r\n\t\tcontrollers\r\n\t) {\r\n\t\tvar node = cached.nodes[0]\r\n\r\n\t\tif (hasKeys) {\r\n\t\t\tsetAttributes(node, data.tag, data.attrs, cached.attrs, namespace)\r\n\t\t}\r\n\r\n\t\tcached.children = build(\r\n\t\t\tnode,\r\n\t\t\tdata.tag,\r\n\t\t\tundefined,\r\n\t\t\tundefined,\r\n\t\t\tdata.children,\r\n\t\t\tcached.children,\r\n\t\t\tfalse,\r\n\t\t\t0,\r\n\t\t\tdata.attrs.contenteditable ? node : editable,\r\n\t\t\tnamespace,\r\n\t\t\tconfigs\r\n\t\t)\r\n\r\n\t\tcached.nodes.intact = true\r\n\r\n\t\tif (controllers.length) {\r\n\t\t\tcached.views = views\r\n\t\t\tcached.controllers = controllers\r\n\t\t}\r\n\r\n\t\treturn node\r\n\t}\r\n\r\n\tfunction handleNonexistentNodes(data, parentElement, index) {\r\n\t\tvar nodes\r\n\t\tif (data.$trusted) {\r\n\t\t\tnodes = injectHTML(parentElement, index, data)\r\n\t\t} else {\r\n\t\t\tnodes = [$document.createTextNode(data)]\r\n\t\t\tif (!(parentElement.nodeName in voidElements)) {\r\n\t\t\t\tinsertNode(parentElement, nodes[0], index)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar cached\r\n\r\n\t\tif (typeof data === \"string\" ||\r\n\t\t\t\ttypeof data === \"number\" ||\r\n\t\t\t\ttypeof data === \"boolean\") {\r\n\t\t\tcached = new data.constructor(data)\r\n\t\t} else {\r\n\t\t\tcached = data\r\n\t\t}\r\n\r\n\t\tcached.nodes = nodes\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction reattachNodes(\r\n\t\tdata,\r\n\t\tcached,\r\n\t\tparentElement,\r\n\t\teditable,\r\n\t\tindex,\r\n\t\tparentTag\r\n\t) {\r\n\t\tvar nodes = cached.nodes\r\n\t\tif (!editable || editable !== $document.activeElement) {\r\n\t\t\tif (data.$trusted) {\r\n\t\t\t\tclear(nodes, cached)\r\n\t\t\t\tnodes = injectHTML(parentElement, index, data)\r\n\t\t\t} else if (parentTag === \"textarea\") {\r\n\t\t\t\t// <textarea> uses `value` instead of `nodeValue`.\r\n\t\t\t\tparentElement.value = data\r\n\t\t\t} else if (editable) {\r\n\t\t\t\t// contenteditable nodes use `innerHTML` instead of `nodeValue`.\r\n\t\t\t\teditable.innerHTML = data\r\n\t\t\t} else {\r\n\t\t\t\t// was a trusted string\r\n\t\t\t\tif (nodes[0].nodeType === 1 || nodes.length > 1 ||\r\n\t\t\t\t\t\t(nodes[0].nodeValue.trim &&\r\n\t\t\t\t\t\t\t!nodes[0].nodeValue.trim())) {\r\n\t\t\t\t\tclear(cached.nodes, cached)\r\n\t\t\t\t\tnodes = [$document.createTextNode(data)]\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinjectTextNode(parentElement, nodes[0], index, data)\r\n\t\t\t}\r\n\t\t}\r\n\t\tcached = new data.constructor(data)\r\n\t\tcached.nodes = nodes\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction handleTextNode(\r\n\t\tcached,\r\n\t\tdata,\r\n\t\tindex,\r\n\t\tparentElement,\r\n\t\tshouldReattach,\r\n\t\teditable,\r\n\t\tparentTag\r\n\t) {\r\n\t\tif (!cached.nodes.length) {\r\n\t\t\treturn handleNonexistentNodes(data, parentElement, index)\r\n\t\t} else if (cached.valueOf() !== data.valueOf() || shouldReattach) {\r\n\t\t\treturn reattachNodes(data, cached, parentElement, editable, index,\r\n\t\t\t\tparentTag)\r\n\t\t} else {\r\n\t\t\treturn (cached.nodes.intact = true, cached)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getSubArrayCount(item) {\r\n\t\tif (item.$trusted) {\r\n\t\t\t// fix offset of next element if item was a trusted string w/ more\r\n\t\t\t// than one html element\r\n\t\t\t// the first clause in the regexp matches elements\r\n\t\t\t// the second clause (after the pipe) matches text nodes\r\n\t\t\tvar match = item.match(/<[^\\/]|\\>\\s*[^<]/g)\r\n\t\t\tif (match != null) return match.length\r\n\t\t} else if (isArray(item)) {\r\n\t\t\treturn item.length\r\n\t\t}\r\n\t\treturn 1\r\n\t}\r\n\r\n\tfunction buildArray(\r\n\t\tdata,\r\n\t\tcached,\r\n\t\tparentElement,\r\n\t\tindex,\r\n\t\tparentTag,\r\n\t\tshouldReattach,\r\n\t\teditable,\r\n\t\tnamespace,\r\n\t\tconfigs\r\n\t) {\r\n\t\tdata = flatten(data)\r\n\t\tvar nodes = []\r\n\t\tvar intact = cached.length === data.length\r\n\t\tvar subArrayCount = 0\r\n\r\n\t\t// keys algorithm: sort elements without recreating them if keys are\r\n\t\t// present\r\n\t\t//\r\n\t\t// 1) create a map of all existing keys, and mark all for deletion\r\n\t\t// 2) add new keys to map and mark them for addition\r\n\t\t// 3) if key exists in new list, change action from deletion to a move\r\n\t\t// 4) for each key, handle its corresponding action as marked in\r\n\t\t//    previous steps\r\n\r\n\t\tvar existing = {}\r\n\t\tvar shouldMaintainIdentities = false\r\n\r\n\t\tforKeys(cached, function (attrs, i) {\r\n\t\t\tshouldMaintainIdentities = true\r\n\t\t\texisting[cached[i].attrs.key] = {action: DELETION, index: i}\r\n\t\t})\r\n\r\n\t\tbuildArrayKeys(data)\r\n\t\tif (shouldMaintainIdentities) {\r\n\t\t\tcached = diffKeys(data, cached, existing, parentElement)\r\n\t\t}\r\n\t\t// end key algorithm\r\n\r\n\t\tvar cacheCount = 0\r\n\t\t// faster explicitly written\r\n\t\tfor (var i = 0, len = data.length; i < len; i++) {\r\n\t\t\t// diff each item in the array\r\n\t\t\tvar item = build(\r\n\t\t\t\tparentElement,\r\n\t\t\t\tparentTag,\r\n\t\t\t\tcached,\r\n\t\t\t\tindex,\r\n\t\t\t\tdata[i],\r\n\t\t\t\tcached[cacheCount],\r\n\t\t\t\tshouldReattach,\r\n\t\t\t\tindex + subArrayCount || subArrayCount,\r\n\t\t\t\teditable,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tconfigs)\r\n\r\n\t\t\tif (item !== undefined) {\r\n\t\t\t\tintact = intact && item.nodes.intact\r\n\t\t\t\tsubArrayCount += getSubArrayCount(item)\r\n\t\t\t\tcached[cacheCount++] = item\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!intact) diffArray(data, cached, nodes)\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction makeCache(data, cached, index, parentIndex, parentCache) {\r\n\t\tif (cached != null) {\r\n\t\t\tif (type.call(cached) === type.call(data)) return cached\r\n\r\n\t\t\tif (parentCache && parentCache.nodes) {\r\n\t\t\t\tvar offset = index - parentIndex\r\n\t\t\t\tvar end = offset + (isArray(data) ? data : cached.nodes).length\r\n\t\t\t\tclear(\r\n\t\t\t\t\tparentCache.nodes.slice(offset, end),\r\n\t\t\t\t\tparentCache.slice(offset, end))\r\n\t\t\t} else if (cached.nodes) {\r\n\t\t\t\tclear(cached.nodes, cached)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcached = new data.constructor()\r\n\t\t// if constructor creates a virtual dom element, use a blank object as\r\n\t\t// the base cached node instead of copying the virtual el (#277)\r\n\t\tif (cached.tag) cached = {}\r\n\t\tcached.nodes = []\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction constructNode(data, namespace) {\r\n\t\tif (data.attrs.is) {\r\n\t\t\tif (namespace == null) {\r\n\t\t\t\treturn $document.createElement(data.tag, data.attrs.is)\r\n\t\t\t} else {\r\n\t\t\t\treturn $document.createElementNS(namespace, data.tag,\r\n\t\t\t\t\tdata.attrs.is)\r\n\t\t\t}\r\n\t\t} else if (namespace == null) {\r\n\t\t\treturn $document.createElement(data.tag)\r\n\t\t} else {\r\n\t\t\treturn $document.createElementNS(namespace, data.tag)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction constructAttrs(data, node, namespace, hasKeys) {\r\n\t\tif (hasKeys) {\r\n\t\t\treturn setAttributes(node, data.tag, data.attrs, {}, namespace)\r\n\t\t} else {\r\n\t\t\treturn data.attrs\r\n\t\t}\r\n\t}\r\n\r\n\tfunction constructChildren(\r\n\t\tdata,\r\n\t\tnode,\r\n\t\tcached,\r\n\t\teditable,\r\n\t\tnamespace,\r\n\t\tconfigs\r\n\t) {\r\n\t\tif (data.children != null && data.children.length > 0) {\r\n\t\t\treturn build(\r\n\t\t\t\tnode,\r\n\t\t\t\tdata.tag,\r\n\t\t\t\tundefined,\r\n\t\t\t\tundefined,\r\n\t\t\t\tdata.children,\r\n\t\t\t\tcached.children,\r\n\t\t\t\ttrue,\r\n\t\t\t\t0,\r\n\t\t\t\tdata.attrs.contenteditable ? node : editable,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tconfigs)\r\n\t\t} else {\r\n\t\t\treturn data.children\r\n\t\t}\r\n\t}\r\n\r\n\tfunction reconstructCached(\r\n\t\tdata,\r\n\t\tattrs,\r\n\t\tchildren,\r\n\t\tnode,\r\n\t\tnamespace,\r\n\t\tviews,\r\n\t\tcontrollers\r\n\t) {\r\n\t\tvar cached = {\r\n\t\t\ttag: data.tag,\r\n\t\t\tattrs: attrs,\r\n\t\t\tchildren: children,\r\n\t\t\tnodes: [node]\r\n\t\t}\r\n\r\n\t\tunloadCachedControllers(cached, views, controllers)\r\n\r\n\t\tif (cached.children && !cached.children.nodes) {\r\n\t\t\tcached.children.nodes = []\r\n\t\t}\r\n\r\n\t\t// edge case: setting value on <select> doesn't work before children\r\n\t\t// exist, so set it again after children have been created\r\n\t\tif (data.tag === \"select\" && \"value\" in data.attrs) {\r\n\t\t\tsetAttributes(node, data.tag, {value: data.attrs.value}, {},\r\n\t\t\t\tnamespace)\r\n\t\t}\r\n\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction getController(views, view, cachedControllers, controller) {\r\n\t\tvar controllerIndex\r\n\r\n\t\tif (m.redraw.strategy() === \"diff\" && views) {\r\n\t\t\tcontrollerIndex = views.indexOf(view)\r\n\t\t} else {\r\n\t\t\tcontrollerIndex = -1\r\n\t\t}\r\n\r\n\t\tif (controllerIndex > -1) {\r\n\t\t\treturn cachedControllers[controllerIndex]\r\n\t\t} else if (isFunction(controller)) {\r\n\t\t\treturn new controller()\r\n\t\t} else {\r\n\t\t\treturn {}\r\n\t\t}\r\n\t}\r\n\r\n\tvar unloaders = []\r\n\r\n\tfunction updateLists(views, controllers, view, controller) {\r\n\t\tif (controller.onunload != null && unloaders.map(function(u) {return u.handler}).indexOf(controller.onunload) < 0) {\r\n\t\t\tunloaders.push({\r\n\t\t\t\tcontroller: controller,\r\n\t\t\t\thandler: controller.onunload\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tviews.push(view)\r\n\t\tcontrollers.push(controller)\r\n\t}\r\n\r\n\tvar forcing = false\r\n\tfunction checkView(data, view, cached, cachedControllers, controllers, views) {\r\n\t\tvar controller = getController(cached.views, view, cachedControllers, data.controller)\r\n\t\tvar key = data && data.attrs && data.attrs.key\r\n\t\tdata = pendingRequests === 0 || forcing || cachedControllers && cachedControllers.indexOf(controller) > -1 ? data.view(controller) : {tag: \"placeholder\"}\r\n\t\tif (data.subtree === \"retain\") return data;\r\n\t\tdata.attrs = data.attrs || {}\r\n\t\tdata.attrs.key = key\r\n\t\tupdateLists(views, controllers, view, controller)\r\n\t\treturn data\r\n\t}\r\n\r\n\tfunction markViews(data, cached, views, controllers) {\r\n\t\tvar cachedControllers = cached && cached.controllers\r\n\r\n\t\twhile (data.view != null) {\r\n\t\t\tdata = checkView(\r\n\t\t\t\tdata,\r\n\t\t\t\tdata.view.$original || data.view,\r\n\t\t\t\tcached,\r\n\t\t\t\tcachedControllers,\r\n\t\t\t\tcontrollers,\r\n\t\t\t\tviews)\r\n\t\t}\r\n\r\n\t\treturn data\r\n\t}\r\n\r\n\tfunction buildObject( // eslint-disable-line max-statements\r\n\t\tdata,\r\n\t\tcached,\r\n\t\teditable,\r\n\t\tparentElement,\r\n\t\tindex,\r\n\t\tshouldReattach,\r\n\t\tnamespace,\r\n\t\tconfigs\r\n\t) {\r\n\t\tvar views = []\r\n\t\tvar controllers = []\r\n\r\n\t\tdata = markViews(data, cached, views, controllers)\r\n\r\n\t\tif (data.subtree === \"retain\") return cached\r\n\r\n\t\tif (!data.tag && controllers.length) {\r\n\t\t\tthrow new Error(\"Component template must return a virtual \" +\r\n\t\t\t\t\"element, not an array, string, etc.\")\r\n\t\t}\r\n\r\n\t\tdata.attrs = data.attrs || {}\r\n\t\tcached.attrs = cached.attrs || {}\r\n\r\n\t\tvar dataAttrKeys = Object.keys(data.attrs)\r\n\t\tvar hasKeys = dataAttrKeys.length > (\"key\" in data.attrs ? 1 : 0)\r\n\r\n\t\tmaybeRecreateObject(data, cached, dataAttrKeys)\r\n\r\n\t\tif (!isString(data.tag)) return\r\n\r\n\t\tvar isNew = cached.nodes.length === 0\r\n\r\n\t\tnamespace = getObjectNamespace(data, namespace)\r\n\r\n\t\tvar node\r\n\t\tif (isNew) {\r\n\t\t\tnode = constructNode(data, namespace)\r\n\t\t\t// set attributes first, then create children\r\n\t\t\tvar attrs = constructAttrs(data, node, namespace, hasKeys)\r\n\r\n\t\t\tvar children = constructChildren(data, node, cached, editable,\r\n\t\t\t\tnamespace, configs)\r\n\r\n\t\t\tcached = reconstructCached(\r\n\t\t\t\tdata,\r\n\t\t\t\tattrs,\r\n\t\t\t\tchildren,\r\n\t\t\t\tnode,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tviews,\r\n\t\t\t\tcontrollers)\r\n\t\t} else {\r\n\t\t\tnode = buildUpdatedNode(\r\n\t\t\t\tcached,\r\n\t\t\t\tdata,\r\n\t\t\t\teditable,\r\n\t\t\t\thasKeys,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tviews,\r\n\t\t\t\tconfigs,\r\n\t\t\t\tcontrollers)\r\n\t\t}\r\n\r\n\t\tif (isNew || shouldReattach === true && node != null) {\r\n\t\t\tinsertNode(parentElement, node, index)\r\n\t\t}\r\n\r\n\t\t// The configs are called after `build` finishes running\r\n\t\tscheduleConfigsToBeCalled(configs, data, node, isNew, cached)\r\n\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction build(\r\n\t\tparentElement,\r\n\t\tparentTag,\r\n\t\tparentCache,\r\n\t\tparentIndex,\r\n\t\tdata,\r\n\t\tcached,\r\n\t\tshouldReattach,\r\n\t\tindex,\r\n\t\teditable,\r\n\t\tnamespace,\r\n\t\tconfigs\r\n\t) {\r\n\t\t/*\r\n\t\t * `build` is a recursive function that manages creation/diffing/removal\r\n\t\t * of DOM elements based on comparison between `data` and `cached` the\r\n\t\t * diff algorithm can be summarized as this:\r\n\t\t *\r\n\t\t * 1 - compare `data` and `cached`\r\n\t\t * 2 - if they are different, copy `data` to `cached` and update the DOM\r\n\t\t *     based on what the difference is\r\n\t\t * 3 - recursively apply this algorithm for every array and for the\r\n\t\t *     children of every virtual element\r\n\t\t *\r\n\t\t * The `cached` data structure is essentially the same as the previous\r\n\t\t * redraw's `data` data structure, with a few additions:\r\n\t\t * - `cached` always has a property called `nodes`, which is a list of\r\n\t\t *    DOM elements that correspond to the data represented by the\r\n\t\t *    respective virtual element\r\n\t\t * - in order to support attaching `nodes` as a property of `cached`,\r\n\t\t *    `cached` is *always* a non-primitive object, i.e. if the data was\r\n\t\t *    a string, then cached is a String instance. If data was `null` or\r\n\t\t *    `undefined`, cached is `new String(\"\")`\r\n\t\t * - `cached also has a `configContext` property, which is the state\r\n\t\t *    storage object exposed by config(element, isInitialized, context)\r\n\t\t * - when `cached` is an Object, it represents a virtual element; when\r\n\t\t *    it's an Array, it represents a list of elements; when it's a\r\n\t\t *    String, Number or Boolean, it represents a text node\r\n\t\t *\r\n\t\t * `parentElement` is a DOM element used for W3C DOM API calls\r\n\t\t * `parentTag` is only used for handling a corner case for textarea\r\n\t\t * values\r\n\t\t * `parentCache` is used to remove nodes in some multi-node cases\r\n\t\t * `parentIndex` and `index` are used to figure out the offset of nodes.\r\n\t\t * They're artifacts from before arrays started being flattened and are\r\n\t\t * likely refactorable\r\n\t\t * `data` and `cached` are, respectively, the new and old nodes being\r\n\t\t * diffed\r\n\t\t * `shouldReattach` is a flag indicating whether a parent node was\r\n\t\t * recreated (if so, and if this node is reused, then this node must\r\n\t\t * reattach itself to the new parent)\r\n\t\t * `editable` is a flag that indicates whether an ancestor is\r\n\t\t * contenteditable\r\n\t\t * `namespace` indicates the closest HTML namespace as it cascades down\r\n\t\t * from an ancestor\r\n\t\t * `configs` is a list of config functions to run after the topmost\r\n\t\t * `build` call finishes running\r\n\t\t *\r\n\t\t * there's logic that relies on the assumption that null and undefined\r\n\t\t * data are equivalent to empty strings\r\n\t\t * - this prevents lifecycle surprises from procedural helpers that mix\r\n\t\t *   implicit and explicit return statements (e.g.\r\n\t\t *   function foo() {if (cond) return m(\"div\")}\r\n\t\t * - it simplifies diffing code\r\n\t\t */\r\n\t\tdata = dataToString(data)\r\n\t\tif (data.subtree === \"retain\") return cached\r\n\t\tcached = makeCache(data, cached, index, parentIndex, parentCache)\r\n\r\n\t\tif (isArray(data)) {\r\n\t\t\treturn buildArray(\r\n\t\t\t\tdata,\r\n\t\t\t\tcached,\r\n\t\t\t\tparentElement,\r\n\t\t\t\tindex,\r\n\t\t\t\tparentTag,\r\n\t\t\t\tshouldReattach,\r\n\t\t\t\teditable,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tconfigs)\r\n\t\t} else if (data != null && isObject(data)) {\r\n\t\t\treturn buildObject(\r\n\t\t\t\tdata,\r\n\t\t\t\tcached,\r\n\t\t\t\teditable,\r\n\t\t\t\tparentElement,\r\n\t\t\t\tindex,\r\n\t\t\t\tshouldReattach,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tconfigs)\r\n\t\t} else if (!isFunction(data)) {\r\n\t\t\treturn handleTextNode(\r\n\t\t\t\tcached,\r\n\t\t\t\tdata,\r\n\t\t\t\tindex,\r\n\t\t\t\tparentElement,\r\n\t\t\t\tshouldReattach,\r\n\t\t\t\teditable,\r\n\t\t\t\tparentTag)\r\n\t\t} else {\r\n\t\t\treturn cached\r\n\t\t}\r\n\t}\r\n\r\n\tfunction sortChanges(a, b) {\r\n\t\treturn a.action - b.action || a.index - b.index\r\n\t}\r\n\r\n\tfunction copyStyleAttrs(node, dataAttr, cachedAttr) {\r\n\t\tfor (var rule in dataAttr) if (hasOwn.call(dataAttr, rule)) {\r\n\t\t\tif (cachedAttr == null || cachedAttr[rule] !== dataAttr[rule]) {\r\n\t\t\t\tnode.style[rule] = dataAttr[rule]\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (rule in cachedAttr) if (hasOwn.call(cachedAttr, rule)) {\r\n\t\t\tif (!hasOwn.call(dataAttr, rule)) node.style[rule] = \"\"\r\n\t\t}\r\n\t}\r\n\r\n\tvar shouldUseSetAttribute = {\r\n\t\tlist: 1,\r\n\t\tstyle: 1,\r\n\t\tform: 1,\r\n\t\ttype: 1,\r\n\t\twidth: 1,\r\n\t\theight: 1\r\n\t}\r\n\r\n\tfunction setSingleAttr(\r\n\t\tnode,\r\n\t\tattrName,\r\n\t\tdataAttr,\r\n\t\tcachedAttr,\r\n\t\ttag,\r\n\t\tnamespace\r\n\t) {\r\n\t\tif (attrName === \"config\" || attrName === \"key\") {\r\n\t\t\t// `config` isn't a real attribute, so ignore it\r\n\t\t\treturn true\r\n\t\t} else if (isFunction(dataAttr) && attrName.slice(0, 2) === \"on\") {\r\n\t\t\t// hook event handlers to the auto-redrawing system\r\n\t\t\tnode[attrName] = autoredraw(dataAttr, node)\r\n\t\t} else if (attrName === \"style\" && dataAttr != null &&\r\n\t\t\t\tisObject(dataAttr)) {\r\n\t\t\t// handle `style: {...}`\r\n\t\t\tcopyStyleAttrs(node, dataAttr, cachedAttr)\r\n\t\t} else if (namespace != null) {\r\n\t\t\t// handle SVG\r\n\t\t\tif (attrName === \"href\") {\r\n\t\t\t\tnode.setAttributeNS(\"http://www.w3.org/1999/xlink\",\r\n\t\t\t\t\t\"href\", dataAttr)\r\n\t\t\t} else {\r\n\t\t\t\tnode.setAttribute(\r\n\t\t\t\t\tattrName === \"className\" ? \"class\" : attrName,\r\n\t\t\t\t\tdataAttr)\r\n\t\t\t}\r\n\t\t} else if (attrName in node && !shouldUseSetAttribute[attrName]) {\r\n\t\t\t// handle cases that are properties (but ignore cases where we\r\n\t\t\t// should use setAttribute instead)\r\n\t\t\t//\r\n\t\t\t// - list and form are typically used as strings, but are DOM\r\n\t\t\t//   element references in js\r\n\t\t\t//\r\n\t\t\t// - when using CSS selectors (e.g. `m(\"[style='']\")`), style is\r\n\t\t\t//   used as a string, but it's an object in js\r\n\t\t\t//\r\n\t\t\t// #348 don't set the value if not needed - otherwise, cursor\r\n\t\t\t// placement breaks in Chrome\r\n\t\t\ttry {\r\n\t\t\t\tif (tag !== \"input\" || node[attrName] !== dataAttr) {\r\n\t\t\t\t\tnode[attrName] = dataAttr\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\tnode.setAttribute(attrName, dataAttr)\r\n\t\t\t}\r\n\t\t}\r\n\t\telse node.setAttribute(attrName, dataAttr)\r\n\t}\r\n\r\n\tfunction trySetAttr(\r\n\t\tnode,\r\n\t\tattrName,\r\n\t\tdataAttr,\r\n\t\tcachedAttr,\r\n\t\tcachedAttrs,\r\n\t\ttag,\r\n\t\tnamespace\r\n\t) {\r\n\t\tif (!(attrName in cachedAttrs) || (cachedAttr !== dataAttr)) {\r\n\t\t\tcachedAttrs[attrName] = dataAttr\r\n\t\t\ttry {\r\n\t\t\t\treturn setSingleAttr(\r\n\t\t\t\t\tnode,\r\n\t\t\t\t\tattrName,\r\n\t\t\t\t\tdataAttr,\r\n\t\t\t\t\tcachedAttr,\r\n\t\t\t\t\ttag,\r\n\t\t\t\t\tnamespace)\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// swallow IE's invalid argument errors to mimic HTML's\r\n\t\t\t\t// fallback-to-doing-nothing-on-invalid-attributes behavior\r\n\t\t\t\tif (e.message.indexOf(\"Invalid argument\") < 0) throw e\r\n\t\t\t}\r\n\t\t} else if (attrName === \"value\" && tag === \"input\" &&\r\n\t\t\t\tnode.value !== dataAttr) {\r\n\t\t\t// #348 dataAttr may not be a string, so use loose comparison\r\n\t\t\tnode.value = dataAttr\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setAttributes(node, tag, dataAttrs, cachedAttrs, namespace) {\r\n\t\tfor (var attrName in dataAttrs) if (hasOwn.call(dataAttrs, attrName)) {\r\n\t\t\tif (trySetAttr(\r\n\t\t\t\t\tnode,\r\n\t\t\t\t\tattrName,\r\n\t\t\t\t\tdataAttrs[attrName],\r\n\t\t\t\t\tcachedAttrs[attrName],\r\n\t\t\t\t\tcachedAttrs,\r\n\t\t\t\t\ttag,\r\n\t\t\t\t\tnamespace)) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cachedAttrs\r\n\t}\r\n\r\n\tfunction clear(nodes, cached) {\r\n\t\tfor (var i = nodes.length - 1; i > -1; i--) {\r\n\t\t\tif (nodes[i] && nodes[i].parentNode) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tnodes[i].parentNode.removeChild(nodes[i])\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\t/* eslint-disable max-len */\r\n\t\t\t\t\t// ignore if this fails due to order of events (see\r\n\t\t\t\t\t// http://stackoverflow.com/questions/21926083/failed-to-execute-removechild-on-node)\r\n\t\t\t\t\t/* eslint-enable max-len */\r\n\t\t\t\t}\r\n\t\t\t\tcached = [].concat(cached)\r\n\t\t\t\tif (cached[i]) unload(cached[i])\r\n\t\t\t}\r\n\t\t}\r\n\t\t// release memory if nodes is an array. This check should fail if nodes\r\n\t\t// is a NodeList (see loop above)\r\n\t\tif (nodes.length) {\r\n\t\t\tnodes.length = 0\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unload(cached) {\r\n\t\tif (cached.configContext && isFunction(cached.configContext.onunload)) {\r\n\t\t\tcached.configContext.onunload()\r\n\t\t\tcached.configContext.onunload = null\r\n\t\t}\r\n\t\tif (cached.controllers) {\r\n\t\t\tforEach(cached.controllers, function (controller) {\r\n\t\t\t\tif (isFunction(controller.onunload)) {\r\n\t\t\t\t\tcontroller.onunload({preventDefault: noop})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\tif (cached.children) {\r\n\t\t\tif (isArray(cached.children)) forEach(cached.children, unload)\r\n\t\t\telse if (cached.children.tag) unload(cached.children)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction appendTextFragment(parentElement, data) {\r\n\t\ttry {\r\n\t\t\tparentElement.appendChild(\r\n\t\t\t\t$document.createRange().createContextualFragment(data))\r\n\t\t} catch (e) {\r\n\t\t\tparentElement.insertAdjacentHTML(\"beforeend\", data)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction injectHTML(parentElement, index, data) {\r\n\t\tvar nextSibling = parentElement.childNodes[index]\r\n\t\tif (nextSibling) {\r\n\t\t\tvar isElement = nextSibling.nodeType !== 1\r\n\t\t\tvar placeholder = $document.createElement(\"span\")\r\n\t\t\tif (isElement) {\r\n\t\t\t\tparentElement.insertBefore(placeholder, nextSibling || null)\r\n\t\t\t\tplaceholder.insertAdjacentHTML(\"beforebegin\", data)\r\n\t\t\t\tparentElement.removeChild(placeholder)\r\n\t\t\t} else {\r\n\t\t\t\tnextSibling.insertAdjacentHTML(\"beforebegin\", data)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tappendTextFragment(parentElement, data)\r\n\t\t}\r\n\r\n\t\tvar nodes = []\r\n\r\n\t\twhile (parentElement.childNodes[index] !== nextSibling) {\r\n\t\t\tnodes.push(parentElement.childNodes[index])\r\n\t\t\tindex++\r\n\t\t}\r\n\r\n\t\treturn nodes\r\n\t}\r\n\r\n\tfunction autoredraw(callback, object) {\r\n\t\treturn function (e) {\r\n\t\t\te = e || event\r\n\t\t\tm.redraw.strategy(\"diff\")\r\n\t\t\tm.startComputation()\r\n\t\t\ttry {\r\n\t\t\t\treturn callback.call(object, e)\r\n\t\t\t} finally {\r\n\t\t\t\tendFirstComputation()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvar html\r\n\tvar documentNode = {\r\n\t\tappendChild: function (node) {\r\n\t\t\tif (html === undefined) html = $document.createElement(\"html\")\r\n\t\t\tif ($document.documentElement &&\r\n\t\t\t\t\t$document.documentElement !== node) {\r\n\t\t\t\t$document.replaceChild(node, $document.documentElement)\r\n\t\t\t} else {\r\n\t\t\t\t$document.appendChild(node)\r\n\t\t\t}\r\n\r\n\t\t\tthis.childNodes = $document.childNodes\r\n\t\t},\r\n\r\n\t\tinsertBefore: function (node) {\r\n\t\t\tthis.appendChild(node)\r\n\t\t},\r\n\r\n\t\tchildNodes: []\r\n\t}\r\n\r\n\tvar nodeCache = []\r\n\tvar cellCache = {}\r\n\r\n\tm.render = function (root, cell, forceRecreation) {\r\n\t\tif (!root) {\r\n\t\t\tthrow new Error(\"Ensure the DOM element being passed to \" +\r\n\t\t\t\t\"m.route/m.mount/m.render is not undefined.\")\r\n\t\t}\r\n\t\tvar configs = []\r\n\t\tvar id = getCellCacheKey(root)\r\n\t\tvar isDocumentRoot = root === $document\r\n\t\tvar node\r\n\r\n\t\tif (isDocumentRoot || root === $document.documentElement) {\r\n\t\t\tnode = documentNode\r\n\t\t} else {\r\n\t\t\tnode = root\r\n\t\t}\r\n\r\n\t\tif (isDocumentRoot && cell.tag !== \"html\") {\r\n\t\t\tcell = {tag: \"html\", attrs: {}, children: cell}\r\n\t\t}\r\n\r\n\t\tif (cellCache[id] === undefined) clear(node.childNodes)\r\n\t\tif (forceRecreation === true) reset(root)\r\n\r\n\t\tcellCache[id] = build(\r\n\t\t\tnode,\r\n\t\t\tnull,\r\n\t\t\tundefined,\r\n\t\t\tundefined,\r\n\t\t\tcell,\r\n\t\t\tcellCache[id],\r\n\t\t\tfalse,\r\n\t\t\t0,\r\n\t\t\tnull,\r\n\t\t\tundefined,\r\n\t\t\tconfigs)\r\n\r\n\t\tforEach(configs, function (config) { config() })\r\n\t}\r\n\r\n\tfunction getCellCacheKey(element) {\r\n\t\tvar index = nodeCache.indexOf(element)\r\n\t\treturn index < 0 ? nodeCache.push(element) - 1 : index\r\n\t}\r\n\r\n\tm.trust = function (value) {\r\n\t\tvalue = new String(value) // eslint-disable-line no-new-wrappers\r\n\t\tvalue.$trusted = true\r\n\t\treturn value\r\n\t}\r\n\r\n\tfunction gettersetter(store) {\r\n\t\tfunction prop() {\r\n\t\t\tif (arguments.length) store = arguments[0]\r\n\t\t\treturn store\r\n\t\t}\r\n\r\n\t\tprop.toJSON = function () {\r\n\t\t\treturn store\r\n\t\t}\r\n\r\n\t\treturn prop\r\n\t}\r\n\r\n\tm.prop = function (store) {\r\n\t\tif ((store != null && isObject(store) || isFunction(store)) &&\r\n\t\t\t\tisFunction(store.then)) {\r\n\t\t\treturn propify(store)\r\n\t\t}\r\n\r\n\t\treturn gettersetter(store)\r\n\t}\r\n\r\n\tvar roots = []\r\n\tvar components = []\r\n\tvar controllers = []\r\n\tvar lastRedrawId = null\r\n\tvar lastRedrawCallTime = 0\r\n\tvar computePreRedrawHook = null\r\n\tvar computePostRedrawHook = null\r\n\tvar topComponent\r\n\tvar FRAME_BUDGET = 16 // 60 frames per second = 1 call per 16 ms\r\n\r\n\tfunction parameterize(component, args) {\r\n\t\tfunction controller() {\r\n\t\t\t/* eslint-disable no-invalid-this */\r\n\t\t\treturn (component.controller || noop).apply(this, args) || this\r\n\t\t\t/* eslint-enable no-invalid-this */\r\n\t\t}\r\n\r\n\t\tif (component.controller) {\r\n\t\t\tcontroller.prototype = component.controller.prototype\r\n\t\t}\r\n\r\n\t\tfunction view(ctrl) {\r\n\t\t\tvar currentArgs = [ctrl].concat(args)\r\n\t\t\tfor (var i = 1; i < arguments.length; i++) {\r\n\t\t\t\tcurrentArgs.push(arguments[i])\r\n\t\t\t}\r\n\r\n\t\t\treturn component.view.apply(component, currentArgs)\r\n\t\t}\r\n\r\n\t\tview.$original = component.view\r\n\t\tvar output = {controller: controller, view: view}\r\n\t\tif (args[0] && args[0].key != null) output.attrs = {key: args[0].key}\r\n\t\treturn output\r\n\t}\r\n\r\n\tm.component = function (component) {\r\n\t\tvar args = [].slice.call(arguments, 1)\r\n\r\n\t\treturn parameterize(component, args)\r\n\t}\r\n\r\n\tfunction checkPrevented(component, root, index, isPrevented) {\r\n\t\tif (!isPrevented) {\r\n\t\t\tm.redraw.strategy(\"all\")\r\n\t\t\tm.startComputation()\r\n\t\t\troots[index] = root\r\n\t\t\tvar currentComponent\r\n\r\n\t\t\tif (component) {\r\n\t\t\t\tcurrentComponent = topComponent = component\r\n\t\t\t} else {\r\n\t\t\t\tcurrentComponent = topComponent = component = {controller: noop}\r\n\t\t\t}\r\n\r\n\t\t\tvar controller = new (component.controller || noop)()\r\n\r\n\t\t\t// controllers may call m.mount recursively (via m.route redirects,\r\n\t\t\t// for example)\r\n\t\t\t// this conditional ensures only the last recursive m.mount call is\r\n\t\t\t// applied\r\n\t\t\tif (currentComponent === topComponent) {\r\n\t\t\t\tcontrollers[index] = controller\r\n\t\t\t\tcomponents[index] = component\r\n\t\t\t}\r\n\t\t\tendFirstComputation()\r\n\t\t\tif (component === null) {\r\n\t\t\t\tremoveRootElement(root, index)\r\n\t\t\t}\r\n\t\t\treturn controllers[index]\r\n\t\t} else if (component == null) {\r\n\t\t\tremoveRootElement(root, index)\r\n\t\t}\r\n\t}\r\n\r\n\tm.mount = m.module = function (root, component) {\r\n\t\tif (!root) {\r\n\t\t\tthrow new Error(\"Please ensure the DOM element exists before \" +\r\n\t\t\t\t\"rendering a template into it.\")\r\n\t\t}\r\n\r\n\t\tvar index = roots.indexOf(root)\r\n\t\tif (index < 0) index = roots.length\r\n\r\n\t\tvar isPrevented = false\r\n\t\tvar event = {\r\n\t\t\tpreventDefault: function () {\r\n\t\t\t\tisPrevented = true\r\n\t\t\t\tcomputePreRedrawHook = computePostRedrawHook = null\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tforEach(unloaders, function (unloader) {\r\n\t\t\tunloader.handler.call(unloader.controller, event)\r\n\t\t\tunloader.controller.onunload = null\r\n\t\t})\r\n\r\n\t\tif (isPrevented) {\r\n\t\t\tforEach(unloaders, function (unloader) {\r\n\t\t\t\tunloader.controller.onunload = unloader.handler\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\tunloaders = []\r\n\t\t}\r\n\r\n\t\tif (controllers[index] && isFunction(controllers[index].onunload)) {\r\n\t\t\tcontrollers[index].onunload(event)\r\n\t\t}\r\n\r\n\t\treturn checkPrevented(component, root, index, isPrevented)\r\n\t}\r\n\r\n\tfunction removeRootElement(root, index) {\r\n\t\troots.splice(index, 1)\r\n\t\tcontrollers.splice(index, 1)\r\n\t\tcomponents.splice(index, 1)\r\n\t\treset(root)\r\n\t\tnodeCache.splice(getCellCacheKey(root), 1)\r\n\t}\r\n\r\n\tvar redrawing = false\r\n\tm.redraw = function (force) {\r\n\t\tif (redrawing) return\r\n\t\tredrawing = true\r\n\t\tif (force) forcing = true\r\n\r\n\t\ttry {\r\n\t\t\t// lastRedrawId is a positive number if a second redraw is requested\r\n\t\t\t// before the next animation frame\r\n\t\t\t// lastRedrawID is null if it's the first redraw and not an event\r\n\t\t\t// handler\r\n\t\t\tif (lastRedrawId && !force) {\r\n\t\t\t\t// when setTimeout: only reschedule redraw if time between now\r\n\t\t\t\t// and previous redraw is bigger than a frame, otherwise keep\r\n\t\t\t\t// currently scheduled timeout\r\n\t\t\t\t// when rAF: always reschedule redraw\r\n\t\t\t\tif ($requestAnimationFrame === global.requestAnimationFrame ||\r\n\t\t\t\t\t\tnew Date() - lastRedrawCallTime > FRAME_BUDGET) {\r\n\t\t\t\t\tif (lastRedrawId > 0) $cancelAnimationFrame(lastRedrawId)\r\n\t\t\t\t\tlastRedrawId = $requestAnimationFrame(redraw, FRAME_BUDGET)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tredraw()\r\n\t\t\t\tlastRedrawId = $requestAnimationFrame(function () {\r\n\t\t\t\t\tlastRedrawId = null\r\n\t\t\t\t}, FRAME_BUDGET)\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tredrawing = forcing = false\r\n\t\t}\r\n\t}\r\n\r\n\tm.redraw.strategy = m.prop()\r\n\tfunction redraw() {\r\n\t\tif (computePreRedrawHook) {\r\n\t\t\tcomputePreRedrawHook()\r\n\t\t\tcomputePreRedrawHook = null\r\n\t\t}\r\n\t\tforEach(roots, function (root, i) {\r\n\t\t\tvar component = components[i]\r\n\t\t\tif (controllers[i]) {\r\n\t\t\t\tvar args = [controllers[i]]\r\n\t\t\t\tm.render(root,\r\n\t\t\t\t\tcomponent.view ? component.view(controllers[i], args) : \"\")\r\n\t\t\t}\r\n\t\t})\r\n\t\t// after rendering within a routed context, we need to scroll back to\r\n\t\t// the top, and fetch the document title for history.pushState\r\n\t\tif (computePostRedrawHook) {\r\n\t\t\tcomputePostRedrawHook()\r\n\t\t\tcomputePostRedrawHook = null\r\n\t\t}\r\n\t\tlastRedrawId = null\r\n\t\tlastRedrawCallTime = new Date()\r\n\t\tm.redraw.strategy(\"diff\")\r\n\t}\r\n\r\n\tfunction endFirstComputation() {\r\n\t\tif (m.redraw.strategy() === \"none\") {\r\n\t\t\tpendingRequests--\r\n\t\t\tm.redraw.strategy(\"diff\")\r\n\t\t} else {\r\n\t\t\tm.endComputation()\r\n\t\t}\r\n\t}\r\n\r\n\tm.withAttr = function (prop, withAttrCallback, callbackThis) {\r\n\t\treturn function (e) {\r\n\t\t\te = e || event\r\n\t\t\t/* eslint-disable no-invalid-this */\r\n\t\t\tvar currentTarget = e.currentTarget || this\r\n\t\t\tvar _this = callbackThis || this\r\n\t\t\t/* eslint-enable no-invalid-this */\r\n\t\t\tvar target = prop in currentTarget ?\r\n\t\t\t\tcurrentTarget[prop] :\r\n\t\t\t\tcurrentTarget.getAttribute(prop)\r\n\t\t\twithAttrCallback.call(_this, target)\r\n\t\t}\r\n\t}\r\n\r\n\t// routing\r\n\tvar modes = {pathname: \"\", hash: \"#\", search: \"?\"}\r\n\tvar redirect = noop\r\n\tvar isDefaultRoute = false\r\n\tvar routeParams, currentRoute\r\n\r\n\tm.route = function (root, arg1, arg2, vdom) { // eslint-disable-line\r\n\t\t// m.route()\r\n\t\tif (arguments.length === 0) return currentRoute\r\n\t\t// m.route(el, defaultRoute, routes)\r\n\t\tif (arguments.length === 3 && isString(arg1)) {\r\n\t\t\tredirect = function (source) {\r\n\t\t\t\tvar path = currentRoute = normalizeRoute(source)\r\n\t\t\t\tif (!routeByValue(root, arg2, path)) {\r\n\t\t\t\t\tif (isDefaultRoute) {\r\n\t\t\t\t\t\tthrow new Error(\"Ensure the default route matches \" +\r\n\t\t\t\t\t\t\t\"one of the routes defined in m.route\")\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tisDefaultRoute = true\r\n\t\t\t\t\tm.route(arg1, true)\r\n\t\t\t\t\tisDefaultRoute = false\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar listener = m.route.mode === \"hash\" ?\r\n\t\t\t\t\"onhashchange\" :\r\n\t\t\t\t\"onpopstate\"\r\n\r\n\t\t\tglobal[listener] = function () {\r\n\t\t\t\tvar path = $location[m.route.mode]\r\n\t\t\t\tif (m.route.mode === \"pathname\") path += $location.search\r\n\t\t\t\tif (currentRoute !== normalizeRoute(path)) redirect(path)\r\n\t\t\t}\r\n\r\n\t\t\tcomputePreRedrawHook = setScroll\r\n\t\t\tglobal[listener]()\r\n\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// config: m.route\r\n\t\tif (root.addEventListener || root.attachEvent) {\r\n\t\t\tvar base = m.route.mode !== \"pathname\" ? $location.pathname : \"\"\r\n\t\t\troot.href = base + modes[m.route.mode] + vdom.attrs.href\r\n\t\t\tif (root.addEventListener) {\r\n\t\t\t\troot.removeEventListener(\"click\", routeUnobtrusive)\r\n\t\t\t\troot.addEventListener(\"click\", routeUnobtrusive)\r\n\t\t\t} else {\r\n\t\t\t\troot.detachEvent(\"onclick\", routeUnobtrusive)\r\n\t\t\t\troot.attachEvent(\"onclick\", routeUnobtrusive)\r\n\t\t\t}\r\n\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// m.route(route, params, shouldReplaceHistoryEntry)\r\n\t\tif (isString(root)) {\r\n\t\t\tvar oldRoute = currentRoute\r\n\t\t\tcurrentRoute = root\r\n\r\n\t\t\tvar args = arg1 || {}\r\n\t\t\tvar queryIndex = currentRoute.indexOf(\"?\")\r\n\t\t\tvar params\r\n\r\n\t\t\tif (queryIndex > -1) {\r\n\t\t\t\tparams = parseQueryString(currentRoute.slice(queryIndex + 1))\r\n\t\t\t} else {\r\n\t\t\t\tparams = {}\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i in args) if (hasOwn.call(args, i)) {\r\n\t\t\t\tparams[i] = args[i]\r\n\t\t\t}\r\n\r\n\t\t\tvar querystring = buildQueryString(params)\r\n\t\t\tvar currentPath\r\n\r\n\t\t\tif (queryIndex > -1) {\r\n\t\t\t\tcurrentPath = currentRoute.slice(0, queryIndex)\r\n\t\t\t} else {\r\n\t\t\t\tcurrentPath = currentRoute\r\n\t\t\t}\r\n\r\n\t\t\tif (querystring) {\r\n\t\t\t\tcurrentRoute = currentPath +\r\n\t\t\t\t\t(currentPath.indexOf(\"?\") === -1 ? \"?\" : \"&\") +\r\n\t\t\t\t\tquerystring\r\n\t\t\t}\r\n\r\n\t\t\tvar replaceHistory =\r\n\t\t\t\t(arguments.length === 3 ? arg2 : arg1) === true ||\r\n\t\t\t\toldRoute === root\r\n\r\n\t\t\tif (global.history.pushState) {\r\n\t\t\t\tvar method = replaceHistory ? \"replaceState\" : \"pushState\"\r\n\t\t\t\tcomputePreRedrawHook = setScroll\r\n\t\t\t\tcomputePostRedrawHook = function () {\r\n\t\t\t\t\tglobal.history[method](null, $document.title,\r\n\t\t\t\t\t\tmodes[m.route.mode] + currentRoute)\r\n\t\t\t\t}\r\n\t\t\t\tredirect(modes[m.route.mode] + currentRoute)\r\n\t\t\t} else {\r\n\t\t\t\t$location[m.route.mode] = currentRoute\r\n\t\t\t\tredirect(modes[m.route.mode] + currentRoute)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tm.route.param = function (key) {\r\n\t\tif (!routeParams) {\r\n\t\t\tthrow new Error(\"You must call m.route(element, defaultRoute, \" +\r\n\t\t\t\t\"routes) before calling m.route.param()\")\r\n\t\t}\r\n\r\n\t\tif (!key) {\r\n\t\t\treturn routeParams\r\n\t\t}\r\n\r\n\t\treturn routeParams[key]\r\n\t}\r\n\r\n\tm.route.mode = \"search\"\r\n\r\n\tfunction normalizeRoute(route) {\r\n\t\treturn route.slice(modes[m.route.mode].length)\r\n\t}\r\n\r\n\tfunction routeByValue(root, router, path) {\r\n\t\trouteParams = {}\r\n\r\n\t\tvar queryStart = path.indexOf(\"?\")\r\n\t\tif (queryStart !== -1) {\r\n\t\t\trouteParams = parseQueryString(\r\n\t\t\t\tpath.substr(queryStart + 1, path.length))\r\n\t\t\tpath = path.substr(0, queryStart)\r\n\t\t}\r\n\r\n\t\t// Get all routes and check if there's\r\n\t\t// an exact match for the current path\r\n\t\tvar keys = Object.keys(router)\r\n\t\tvar index = keys.indexOf(path)\r\n\r\n\t\tif (index !== -1){\r\n\t\t\tm.mount(root, router[keys [index]])\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\tfor (var route in router) if (hasOwn.call(router, route)) {\r\n\t\t\tif (route === path) {\r\n\t\t\t\tm.mount(root, router[route])\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\r\n\t\t\tvar matcher = new RegExp(\"^\" + route\r\n\t\t\t\t.replace(/:[^\\/]+?\\.{3}/g, \"(.*?)\")\r\n\t\t\t\t.replace(/:[^\\/]+/g, \"([^\\\\/]+)\") + \"\\/?$\")\r\n\r\n\t\t\tif (matcher.test(path)) {\r\n\t\t\t\t/* eslint-disable no-loop-func */\r\n\t\t\t\tpath.replace(matcher, function () {\r\n\t\t\t\t\tvar keys = route.match(/:[^\\/]+/g) || []\r\n\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\r\n\t\t\t\t\tforEach(keys, function (key, i) {\r\n\t\t\t\t\t\trouteParams[key.replace(/:|\\./g, \"\")] =\r\n\t\t\t\t\t\t\tdecodeURIComponent(values[i])\r\n\t\t\t\t\t})\r\n\t\t\t\t\tm.mount(root, router[route])\r\n\t\t\t\t})\r\n\t\t\t\t/* eslint-enable no-loop-func */\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction routeUnobtrusive(e) {\r\n\t\te = e || event\r\n\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\r\n\r\n\t\tif (e.preventDefault) {\r\n\t\t\te.preventDefault()\r\n\t\t} else {\r\n\t\t\te.returnValue = false\r\n\t\t}\r\n\r\n\t\tvar currentTarget = e.currentTarget || e.srcElement\r\n\t\tvar args\r\n\r\n\t\tif (m.route.mode === \"pathname\" && currentTarget.search) {\r\n\t\t\targs = parseQueryString(currentTarget.search.slice(1))\r\n\t\t} else {\r\n\t\t\targs = {}\r\n\t\t}\r\n\r\n\t\twhile (currentTarget && !/a/i.test(currentTarget.nodeName)) {\r\n\t\t\tcurrentTarget = currentTarget.parentNode\r\n\t\t}\r\n\r\n\t\t// clear pendingRequests because we want an immediate route change\r\n\t\tpendingRequests = 0\r\n\t\tm.route(currentTarget[m.route.mode]\r\n\t\t\t.slice(modes[m.route.mode].length), args)\r\n\t}\r\n\r\n\tfunction setScroll() {\r\n\t\tif (m.route.mode !== \"hash\" && $location.hash) {\r\n\t\t\t$location.hash = $location.hash\r\n\t\t} else {\r\n\t\t\tglobal.scrollTo(0, 0)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction buildQueryString(object, prefix) {\r\n\t\tvar duplicates = {}\r\n\t\tvar str = []\r\n\r\n\t\tfor (var prop in object) if (hasOwn.call(object, prop)) {\r\n\t\t\tvar key = prefix ? prefix + \"[\" + prop + \"]\" : prop\r\n\t\t\tvar value = object[prop]\r\n\r\n\t\t\tif (value === null) {\r\n\t\t\t\tstr.push(encodeURIComponent(key))\r\n\t\t\t} else if (isObject(value)) {\r\n\t\t\t\tstr.push(buildQueryString(value, key))\r\n\t\t\t} else if (isArray(value)) {\r\n\t\t\t\tvar keys = []\r\n\t\t\t\tduplicates[key] = duplicates[key] || {}\r\n\t\t\t\t/* eslint-disable no-loop-func */\r\n\t\t\t\tforEach(value, function (item) {\r\n\t\t\t\t\t/* eslint-enable no-loop-func */\r\n\t\t\t\t\tif (!duplicates[key][item]) {\r\n\t\t\t\t\t\tduplicates[key][item] = true\r\n\t\t\t\t\t\tkeys.push(encodeURIComponent(key) + \"=\" +\r\n\t\t\t\t\t\t\tencodeURIComponent(item))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tstr.push(keys.join(\"&\"))\r\n\t\t\t} else if (value !== undefined) {\r\n\t\t\t\tstr.push(encodeURIComponent(key) + \"=\" +\r\n\t\t\t\t\tencodeURIComponent(value))\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn str.join(\"&\")\r\n\t}\r\n\r\n\tfunction parseQueryString(str) {\r\n\t\tif (str === \"\" || str == null) return {}\r\n\t\tif (str.charAt(0) === \"?\") str = str.slice(1)\r\n\r\n\t\tvar pairs = str.split(\"&\")\r\n\t\tvar params = {}\r\n\r\n\t\tforEach(pairs, function (string) {\r\n\t\t\tvar pair = string.split(\"=\")\r\n\t\t\tvar key = decodeURIComponent(pair[0])\r\n\t\t\tvar value = pair.length === 2 ? decodeURIComponent(pair[1]) : null\r\n\t\t\tif (params[key] != null) {\r\n\t\t\t\tif (!isArray(params[key])) params[key] = [params[key]]\r\n\t\t\t\tparams[key].push(value)\r\n\t\t\t}\r\n\t\t\telse params[key] = value\r\n\t\t})\r\n\r\n\t\treturn params\r\n\t}\r\n\r\n\tm.route.buildQueryString = buildQueryString\r\n\tm.route.parseQueryString = parseQueryString\r\n\r\n\tfunction reset(root) {\r\n\t\tvar cacheKey = getCellCacheKey(root)\r\n\t\tclear(root.childNodes, cellCache[cacheKey])\r\n\t\tcellCache[cacheKey] = undefined\r\n\t}\r\n\r\n\tm.deferred = function () {\r\n\t\tvar deferred = new Deferred()\r\n\t\tdeferred.promise = propify(deferred.promise)\r\n\t\treturn deferred\r\n\t}\r\n\r\n\tfunction propify(promise, initialValue) {\r\n\t\tvar prop = m.prop(initialValue)\r\n\t\tpromise.then(prop)\r\n\t\tprop.then = function (resolve, reject) {\r\n\t\t\treturn propify(promise.then(resolve, reject), initialValue)\r\n\t\t}\r\n\r\n\t\tprop.catch = prop.then.bind(null, null)\r\n\t\treturn prop\r\n\t}\r\n\t// Promiz.mithril.js | Zolmeister | MIT\r\n\t// a modified version of Promiz.js, which does not conform to Promises/A+\r\n\t// for two reasons:\r\n\t//\r\n\t// 1) `then` callbacks are called synchronously (because setTimeout is too\r\n\t//    slow, and the setImmediate polyfill is too big\r\n\t//\r\n\t// 2) throwing subclasses of Error cause the error to be bubbled up instead\r\n\t//    of triggering rejection (because the spec does not account for the\r\n\t//    important use case of default browser error handling, i.e. message w/\r\n\t//    line number)\r\n\r\n\tvar RESOLVING = 1\r\n\tvar REJECTING = 2\r\n\tvar RESOLVED = 3\r\n\tvar REJECTED = 4\r\n\r\n\tfunction Deferred(onSuccess, onFailure) {\r\n\t\tvar self = this\r\n\t\tvar state = 0\r\n\t\tvar promiseValue = 0\r\n\t\tvar next = []\r\n\r\n\t\tself.promise = {}\r\n\r\n\t\tself.resolve = function (value) {\r\n\t\t\tif (!state) {\r\n\t\t\t\tpromiseValue = value\r\n\t\t\t\tstate = RESOLVING\r\n\r\n\t\t\t\tfire()\r\n\t\t\t}\r\n\r\n\t\t\treturn self\r\n\t\t}\r\n\r\n\t\tself.reject = function (value) {\r\n\t\t\tif (!state) {\r\n\t\t\t\tpromiseValue = value\r\n\t\t\t\tstate = REJECTING\r\n\r\n\t\t\t\tfire()\r\n\t\t\t}\r\n\r\n\t\t\treturn self\r\n\t\t}\r\n\r\n\t\tself.promise.then = function (onSuccess, onFailure) {\r\n\t\t\tvar deferred = new Deferred(onSuccess, onFailure)\r\n\r\n\t\t\tif (state === RESOLVED) {\r\n\t\t\t\tdeferred.resolve(promiseValue)\r\n\t\t\t} else if (state === REJECTED) {\r\n\t\t\t\tdeferred.reject(promiseValue)\r\n\t\t\t} else {\r\n\t\t\t\tnext.push(deferred)\r\n\t\t\t}\r\n\r\n\t\t\treturn deferred.promise\r\n\t\t}\r\n\r\n\t\tfunction finish(type) {\r\n\t\t\tstate = type || REJECTED\r\n\t\t\tnext.map(function (deferred) {\r\n\t\t\t\tif (state === RESOLVED) {\r\n\t\t\t\t\tdeferred.resolve(promiseValue)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdeferred.reject(promiseValue)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tfunction thennable(then, success, failure, notThennable) {\r\n\t\t\tif (((promiseValue != null && isObject(promiseValue)) ||\r\n\t\t\t\t\tisFunction(promiseValue)) && isFunction(then)) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\t// count protects against abuse calls from spec checker\r\n\t\t\t\t\tvar count = 0\r\n\t\t\t\t\tthen.call(promiseValue, function (value) {\r\n\t\t\t\t\t\tif (count++) return\r\n\t\t\t\t\t\tpromiseValue = value\r\n\t\t\t\t\t\tsuccess()\r\n\t\t\t\t\t}, function (value) {\r\n\t\t\t\t\t\tif (count++) return\r\n\t\t\t\t\t\tpromiseValue = value\r\n\t\t\t\t\t\tfailure()\r\n\t\t\t\t\t})\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.deferred.onerror(e)\r\n\t\t\t\t\tpromiseValue = e\r\n\t\t\t\t\tfailure()\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnotThennable()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction fire() {\r\n\t\t\t// check if it's a thenable\r\n\t\t\tvar then\r\n\t\t\ttry {\r\n\t\t\t\tthen = promiseValue && promiseValue.then\r\n\t\t\t} catch (e) {\r\n\t\t\t\tm.deferred.onerror(e)\r\n\t\t\t\tpromiseValue = e\r\n\t\t\t\tstate = REJECTING\r\n\t\t\t\treturn fire()\r\n\t\t\t}\r\n\r\n\t\t\tif (state === REJECTING) {\r\n\t\t\t\tm.deferred.onerror(promiseValue)\r\n\t\t\t}\r\n\r\n\t\t\tthennable(then, function () {\r\n\t\t\t\tstate = RESOLVING\r\n\t\t\t\tfire()\r\n\t\t\t}, function () {\r\n\t\t\t\tstate = REJECTING\r\n\t\t\t\tfire()\r\n\t\t\t}, function () {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (state === RESOLVING && isFunction(onSuccess)) {\r\n\t\t\t\t\t\tpromiseValue = onSuccess(promiseValue)\r\n\t\t\t\t\t} else if (state === REJECTING && isFunction(onFailure)) {\r\n\t\t\t\t\t\tpromiseValue = onFailure(promiseValue)\r\n\t\t\t\t\t\tstate = RESOLVING\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.deferred.onerror(e)\r\n\t\t\t\t\tpromiseValue = e\r\n\t\t\t\t\treturn finish()\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (promiseValue === self) {\r\n\t\t\t\t\tpromiseValue = TypeError()\r\n\t\t\t\t\tfinish()\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthennable(then, function () {\r\n\t\t\t\t\t\tfinish(RESOLVED)\r\n\t\t\t\t\t}, finish, function () {\r\n\t\t\t\t\t\tfinish(state === RESOLVING && RESOLVED)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tm.deferred.onerror = function (e) {\r\n\t\tif (type.call(e) === \"[object Error]\" &&\r\n\t\t\t\t!/ Error/.test(e.constructor.toString())) {\r\n\t\t\tpendingRequests = 0\r\n\t\t\tthrow e\r\n\t\t}\r\n\t}\r\n\r\n\tm.sync = function (args) {\r\n\t\tvar deferred = m.deferred()\r\n\t\tvar outstanding = args.length\r\n\t\tvar results = new Array(outstanding)\r\n\t\tvar method = \"resolve\"\r\n\r\n\t\tfunction synchronizer(pos, resolved) {\r\n\t\t\treturn function (value) {\r\n\t\t\t\tresults[pos] = value\r\n\t\t\t\tif (!resolved) method = \"reject\"\r\n\t\t\t\tif (--outstanding === 0) {\r\n\t\t\t\t\tdeferred.promise(results)\r\n\t\t\t\t\tdeferred[method](results)\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (args.length > 0) {\r\n\t\t\tforEach(args, function (arg, i) {\r\n\t\t\t\targ.then(synchronizer(i, true), synchronizer(i, false))\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\tdeferred.resolve([])\r\n\t\t}\r\n\r\n\t\treturn deferred.promise\r\n\t}\r\n\r\n\tfunction identity(value) { return value }\r\n\r\n\tfunction handleJsonp(options) {\r\n\t\tvar callbackKey = \"mithril_callback_\" +\r\n\t\t\tnew Date().getTime() + \"_\" +\r\n\t\t\t(Math.round(Math.random() * 1e16)).toString(36)\r\n\r\n\t\tvar script = $document.createElement(\"script\")\r\n\r\n\t\tglobal[callbackKey] = function (resp) {\r\n\t\t\tscript.parentNode.removeChild(script)\r\n\t\t\toptions.onload({\r\n\t\t\t\ttype: \"load\",\r\n\t\t\t\ttarget: {\r\n\t\t\t\t\tresponseText: resp\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tglobal[callbackKey] = undefined\r\n\t\t}\r\n\r\n\t\tscript.onerror = function () {\r\n\t\t\tscript.parentNode.removeChild(script)\r\n\r\n\t\t\toptions.onerror({\r\n\t\t\t\ttype: \"error\",\r\n\t\t\t\ttarget: {\r\n\t\t\t\t\tstatus: 500,\r\n\t\t\t\t\tresponseText: JSON.stringify({\r\n\t\t\t\t\t\terror: \"Error making jsonp request\"\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tglobal[callbackKey] = undefined\r\n\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\tscript.onload = function () {\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\tscript.src = options.url +\r\n\t\t\t(options.url.indexOf(\"?\") > 0 ? \"&\" : \"?\") +\r\n\t\t\t(options.callbackKey ? options.callbackKey : \"callback\") +\r\n\t\t\t\"=\" + callbackKey +\r\n\t\t\t\"&\" + buildQueryString(options.data || {})\r\n\r\n\t\t$document.body.appendChild(script)\r\n\t}\r\n\r\n\tfunction createXhr(options) {\r\n\t\tvar xhr = new global.XMLHttpRequest()\r\n\t\txhr.open(options.method, options.url, true, options.user,\r\n\t\t\toptions.password)\r\n\r\n\t\txhr.onreadystatechange = function () {\r\n\t\t\tif (xhr.readyState === 4) {\r\n\t\t\t\tif (xhr.status >= 200 && xhr.status < 300) {\r\n\t\t\t\t\toptions.onload({type: \"load\", target: xhr})\r\n\t\t\t\t} else {\r\n\t\t\t\t\toptions.onerror({type: \"error\", target: xhr})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (options.serialize === JSON.stringify &&\r\n\t\t\t\toptions.data &&\r\n\t\t\t\toptions.method !== \"GET\") {\r\n\t\t\txhr.setRequestHeader(\"Content-Type\",\r\n\t\t\t\t\"application/json; charset=utf-8\")\r\n\t\t}\r\n\r\n\t\tif (options.deserialize === JSON.parse) {\r\n\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\")\r\n\t\t}\r\n\r\n\t\tif (isFunction(options.config)) {\r\n\t\t\tvar maybeXhr = options.config(xhr, options)\r\n\t\t\tif (maybeXhr != null) xhr = maybeXhr\r\n\t\t}\r\n\r\n\t\tvar data = options.method === \"GET\" || !options.data ? \"\" : options.data\r\n\r\n\t\tif (data && !isString(data) && data.constructor !== global.FormData) {\r\n\t\t\tthrow new Error(\"Request data should be either be a string or \" +\r\n\t\t\t\t\"FormData. Check the `serialize` option in `m.request`\")\r\n\t\t}\r\n\r\n\t\txhr.send(data)\r\n\t\treturn xhr\r\n\t}\r\n\r\n\tfunction ajax(options) {\r\n\t\tif (options.dataType && options.dataType.toLowerCase() === \"jsonp\") {\r\n\t\t\treturn handleJsonp(options)\r\n\t\t} else {\r\n\t\t\treturn createXhr(options)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction bindData(options, data, serialize) {\r\n\t\tif (options.method === \"GET\" && options.dataType !== \"jsonp\") {\r\n\t\t\tvar prefix = options.url.indexOf(\"?\") < 0 ? \"?\" : \"&\"\r\n\t\t\tvar querystring = buildQueryString(data)\r\n\t\t\toptions.url += (querystring ? prefix + querystring : \"\")\r\n\t\t} else {\r\n\t\t\toptions.data = serialize(data)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction parameterizeUrl(url, data) {\r\n\t\tif (data) {\r\n\t\t\turl = url.replace(/:[a-z]\\w+/gi, function(token){\r\n\t\t\t\tvar key = token.slice(1)\r\n\t\t\t\tvar value = data[key]\r\n\t\t\t\tdelete data[key]\r\n\t\t\t\treturn value\r\n\t\t\t})\r\n\t\t}\r\n\t\treturn url\r\n\t}\r\n\r\n\tm.request = function (options) {\r\n\t\tif (options.background !== true) m.startComputation()\r\n\t\tvar deferred = new Deferred()\r\n\t\tvar isJSONP = options.dataType &&\r\n\t\t\toptions.dataType.toLowerCase() === \"jsonp\"\r\n\r\n\t\tvar serialize, deserialize, extract\r\n\r\n\t\tif (isJSONP) {\r\n\t\t\tserialize = options.serialize =\r\n\t\t\tdeserialize = options.deserialize = identity\r\n\r\n\t\t\textract = function (jsonp) { return jsonp.responseText }\r\n\t\t} else {\r\n\t\t\tserialize = options.serialize = options.serialize || JSON.stringify\r\n\r\n\t\t\tdeserialize = options.deserialize =\r\n\t\t\t\toptions.deserialize || JSON.parse\r\n\t\t\textract = options.extract || function (xhr) {\r\n\t\t\t\tif (xhr.responseText.length || deserialize !== JSON.parse) {\r\n\t\t\t\t\treturn xhr.responseText\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn null\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\toptions.method = (options.method || \"GET\").toUpperCase()\r\n\t\toptions.url = parameterizeUrl(options.url, options.data)\r\n\t\tbindData(options, options.data, serialize)\r\n\t\toptions.onload = options.onerror = function (ev) {\r\n\t\t\ttry {\r\n\t\t\t\tev = ev || event\r\n\t\t\t\tvar response = deserialize(extract(ev.target, options))\r\n\t\t\t\tif (ev.type === \"load\") {\r\n\t\t\t\t\tif (options.unwrapSuccess) {\r\n\t\t\t\t\t\tresponse = options.unwrapSuccess(response, ev.target)\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (isArray(response) && options.type) {\r\n\t\t\t\t\t\tforEach(response, function (res, i) {\r\n\t\t\t\t\t\t\tresponse[i] = new options.type(res)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else if (options.type) {\r\n\t\t\t\t\t\tresponse = new options.type(response)\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdeferred.resolve(response)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (options.unwrapError) {\r\n\t\t\t\t\t\tresponse = options.unwrapError(response, ev.target)\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdeferred.reject(response)\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\tdeferred.reject(e)\r\n\t\t\t} finally {\r\n\t\t\t\tif (options.background !== true) m.endComputation()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tajax(options)\r\n\t\tdeferred.promise = propify(deferred.promise, options.initialValue)\r\n\t\treturn deferred.promise\r\n\t}\r\n\r\n\treturn m\r\n})\r\n\n},{}]},{},[1])\n\n","//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.8.3';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result — either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n  _.iteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, undefinedOnly) {\n    return function(obj) {\n      var length = arguments.length;\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var property = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = property('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  function createReduce(dir) {\n    // Optimized iterator function as using arguments.length\n    // in the main function will deoptimize the, see #1991.\n    function iterator(obj, iteratee, memo, keys, index, length) {\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    }\n\n    return function(obj, iteratee, memo, context) {\n      iteratee = optimizeCb(iteratee, context, 4);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      // Determine the initial value if none is provided.\n      if (arguments.length < 3) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      return iterator(obj, iteratee, memo, keys, index, length);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var key;\n    if (isArrayLike(obj)) {\n      key = _.findIndex(obj, predicate, context);\n    } else {\n      key = _.findKey(obj, predicate, context);\n    }\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var set = isArrayLike(obj) ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, startIndex) {\n    var output = [], idx = 0;\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        //flatten current level of array or arguments object\n        if (!shallow) value = flatten(value, shallow, strict);\n        var j = 0, len = value.length;\n        output.length += len;\n        while (j < len) {\n          output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(arguments, true, true, 1);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    return _.unzip(arguments);\n  };\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a predicate test\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n            i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var args = slice.call(arguments, 2);\n    var bound = function() {\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object\n  // In contrast to _.map it returns an object\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys =  _.keys(obj),\n          length = keys.length,\n          results = {},\n          currentKey;\n      for (var index = 0; index < length; index++) {\n        currentKey = keys[index];\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(object, oiteratee, context) {\n    var result = {}, obj = object, iteratee, keys;\n    if (obj == null) return result;\n    if (_.isFunction(oiteratee)) {\n      keys = _.allKeys(obj);\n      iteratee = optimizeCb(oiteratee, context);\n    } else {\n      keys = flatten(arguments, false, false, 1);\n      iteratee = function(value, key, obj) { return key in obj; };\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(flatten(arguments, false, false, 1), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), and in Safari 8 (#1929).\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = property;\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    return obj == null ? function(){} : function(key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property, fallback) {\n    var value = object == null ? void 0 : object[property];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return '' + this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this));\n",";(function (global, factory) { // eslint-disable-line\r\n\t\"use strict\"\r\n\t/* eslint-disable no-undef */\r\n\tvar m = factory(global)\r\n\tif (typeof module === \"object\" && module != null && module.exports) {\r\n\t\tmodule.exports = m\r\n\t} else if (typeof define === \"function\" && define.amd) {\r\n\t\tdefine(function () { return m })\r\n\t} else {\r\n\t\tglobal.m = m\r\n\t}\r\n\t/* eslint-enable no-undef */\r\n})(typeof window !== \"undefined\" ? window : {}, function (global, undefined) { // eslint-disable-line\r\n\t\"use strict\"\r\n\r\n\tm.version = function () {\r\n\t\treturn \"v0.2.3\"\r\n\t}\r\n\r\n\tvar hasOwn = {}.hasOwnProperty\r\n\tvar type = {}.toString\r\n\r\n\tfunction isFunction(object) {\r\n\t\treturn typeof object === \"function\"\r\n\t}\r\n\r\n\tfunction isObject(object) {\r\n\t\treturn type.call(object) === \"[object Object]\"\r\n\t}\r\n\r\n\tfunction isString(object) {\r\n\t\treturn type.call(object) === \"[object String]\"\r\n\t}\r\n\r\n\tvar isArray = Array.isArray || function (object) {\r\n\t\treturn type.call(object) === \"[object Array]\"\r\n\t}\r\n\r\n\tfunction noop() {}\r\n\r\n\tvar voidElements = {\r\n\t\tAREA: 1,\r\n\t\tBASE: 1,\r\n\t\tBR: 1,\r\n\t\tCOL: 1,\r\n\t\tCOMMAND: 1,\r\n\t\tEMBED: 1,\r\n\t\tHR: 1,\r\n\t\tIMG: 1,\r\n\t\tINPUT: 1,\r\n\t\tKEYGEN: 1,\r\n\t\tLINK: 1,\r\n\t\tMETA: 1,\r\n\t\tPARAM: 1,\r\n\t\tSOURCE: 1,\r\n\t\tTRACK: 1,\r\n\t\tWBR: 1\r\n\t}\r\n\r\n\t// caching commonly used variables\r\n\tvar $document, $location, $requestAnimationFrame, $cancelAnimationFrame\r\n\r\n\t// self invoking function needed because of the way mocks work\r\n\tfunction initialize(mock) {\r\n\t\t$document = mock.document\r\n\t\t$location = mock.location\r\n\t\t$cancelAnimationFrame = mock.cancelAnimationFrame || mock.clearTimeout\r\n\t\t$requestAnimationFrame = mock.requestAnimationFrame || mock.setTimeout\r\n\t}\r\n\r\n\t// testing API\r\n\tm.deps = function (mock) {\r\n\t\tinitialize(global = mock || window)\r\n\t\treturn global\r\n\t}\r\n\r\n\tm.deps(global)\r\n\r\n\t/**\r\n\t * @typedef {String} Tag\r\n\t * A string that looks like -> div.classname#id[param=one][param2=two]\r\n\t * Which describes a DOM node\r\n\t */\r\n\r\n\tfunction parseTagAttrs(cell, tag) {\r\n\t\tvar classes = []\r\n\t\tvar parser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[.+?\\])/g\r\n\t\tvar match\r\n\r\n\t\twhile ((match = parser.exec(tag))) {\r\n\t\t\tif (match[1] === \"\" && match[2]) {\r\n\t\t\t\tcell.tag = match[2]\r\n\t\t\t} else if (match[1] === \"#\") {\r\n\t\t\t\tcell.attrs.id = match[2]\r\n\t\t\t} else if (match[1] === \".\") {\r\n\t\t\t\tclasses.push(match[2])\r\n\t\t\t} else if (match[3][0] === \"[\") {\r\n\t\t\t\tvar pair = /\\[(.+?)(?:=(\"|'|)(.*?)\\2)?\\]/.exec(match[3])\r\n\t\t\t\tcell.attrs[pair[1]] = pair[3] || (pair[2] ? \"\" : true)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn classes\r\n\t}\r\n\r\n\tfunction getVirtualChildren(args, hasAttrs) {\r\n\t\tvar children = hasAttrs ? args.slice(1) : args\r\n\r\n\t\tif (children.length === 1 && isArray(children[0])) {\r\n\t\t\treturn children[0]\r\n\t\t} else {\r\n\t\t\treturn children\r\n\t\t}\r\n\t}\r\n\r\n\tfunction assignAttrs(target, attrs, classes) {\r\n\t\tvar classAttr = \"class\" in attrs ? \"class\" : \"className\"\r\n\r\n\t\tfor (var attrName in attrs) {\r\n\t\t\tif (hasOwn.call(attrs, attrName)) {\r\n\t\t\t\tif (attrName === classAttr &&\r\n\t\t\t\t\t\tattrs[attrName] != null &&\r\n\t\t\t\t\t\tattrs[attrName] !== \"\") {\r\n\t\t\t\t\tclasses.push(attrs[attrName])\r\n\t\t\t\t\t// create key in correct iteration order\r\n\t\t\t\t\ttarget[attrName] = \"\"\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttarget[attrName] = attrs[attrName]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (classes.length) target[classAttr] = classes.join(\" \")\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Tag} The DOM node tag\r\n\t * @param {Object=[]} optional key-value pairs to be mapped to DOM attrs\r\n\t * @param {...mNode=[]} Zero or more Mithril child nodes. Can be an array,\r\n\t *                      or splat (optional)\r\n\t */\r\n\tfunction m(tag, pairs) {\r\n\t\tvar args = [].slice.call(arguments, 1)\r\n\r\n\t\tif (isObject(tag)) return parameterize(tag, args)\r\n\r\n\t\tif (!isString(tag)) {\r\n\t\t\tthrow new Error(\"selector in m(selector, attrs, children) should \" +\r\n\t\t\t\t\"be a string\")\r\n\t\t}\r\n\r\n\t\tvar hasAttrs = pairs != null && isObject(pairs) &&\r\n\t\t\t!(\"tag\" in pairs || \"view\" in pairs || \"subtree\" in pairs)\r\n\r\n\t\tvar attrs = hasAttrs ? pairs : {}\r\n\t\tvar cell = {\r\n\t\t\ttag: \"div\",\r\n\t\t\tattrs: {},\r\n\t\t\tchildren: getVirtualChildren(args, hasAttrs)\r\n\t\t}\r\n\r\n\t\tassignAttrs(cell.attrs, attrs, parseTagAttrs(cell, tag))\r\n\t\treturn cell\r\n\t}\r\n\r\n\tfunction forEach(list, f) {\r\n\t\tfor (var i = 0; i < list.length && !f(list[i], i++);) {\r\n\t\t\t// function called in condition\r\n\t\t}\r\n\t}\r\n\r\n\tfunction forKeys(list, f) {\r\n\t\tforEach(list, function (attrs, i) {\r\n\t\t\treturn (attrs = attrs && attrs.attrs) &&\r\n\t\t\t\tattrs.key != null &&\r\n\t\t\t\tf(attrs, i)\r\n\t\t})\r\n\t}\r\n\t// This function was causing deopts in Chrome.\r\n\tfunction dataToString(data) {\r\n\t\t// data.toString() might throw or return null if data is the return\r\n\t\t// value of Console.log in some versions of Firefox (behavior depends on\r\n\t\t// version)\r\n\t\ttry {\r\n\t\t\tif (data != null && data.toString() != null) return data\r\n\t\t} catch (e) {\r\n\t\t\t// silently ignore errors\r\n\t\t}\r\n\t\treturn \"\"\r\n\t}\r\n\r\n\t// This function was causing deopts in Chrome.\r\n\tfunction injectTextNode(parentElement, first, index, data) {\r\n\t\ttry {\r\n\t\t\tinsertNode(parentElement, first, index)\r\n\t\t\tfirst.nodeValue = data\r\n\t\t} catch (e) {\r\n\t\t\t// IE erroneously throws error when appending an empty text node\r\n\t\t\t// after a null\r\n\t\t}\r\n\t}\r\n\r\n\tfunction flatten(list) {\r\n\t\t// recursively flatten array\r\n\t\tfor (var i = 0; i < list.length; i++) {\r\n\t\t\tif (isArray(list[i])) {\r\n\t\t\t\tlist = list.concat.apply([], list)\r\n\t\t\t\t// check current index again and flatten until there are no more\r\n\t\t\t\t// nested arrays at that index\r\n\t\t\t\ti--\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn list\r\n\t}\r\n\r\n\tfunction insertNode(parentElement, node, index) {\r\n\t\tparentElement.insertBefore(node,\r\n\t\t\tparentElement.childNodes[index] || null)\r\n\t}\r\n\r\n\tvar DELETION = 1\r\n\tvar INSERTION = 2\r\n\tvar MOVE = 3\r\n\r\n\tfunction handleKeysDiffer(data, existing, cached, parentElement) {\r\n\t\tforKeys(data, function (key, i) {\r\n\t\t\texisting[key = key.key] = existing[key] ? {\r\n\t\t\t\taction: MOVE,\r\n\t\t\t\tindex: i,\r\n\t\t\t\tfrom: existing[key].index,\r\n\t\t\t\telement: cached.nodes[existing[key].index] ||\r\n\t\t\t\t\t$document.createElement(\"div\")\r\n\t\t\t} : {action: INSERTION, index: i}\r\n\t\t})\r\n\r\n\t\tvar actions = []\r\n\t\tfor (var prop in existing) if (hasOwn.call(existing, prop)) {\r\n\t\t\tactions.push(existing[prop])\r\n\t\t}\r\n\r\n\t\tvar changes = actions.sort(sortChanges)\r\n\t\tvar newCached = new Array(cached.length)\r\n\r\n\t\tnewCached.nodes = cached.nodes.slice()\r\n\r\n\t\tforEach(changes, function (change) {\r\n\t\t\tvar index = change.index\r\n\t\t\tif (change.action === DELETION) {\r\n\t\t\t\tclear(cached[index].nodes, cached[index])\r\n\t\t\t\tnewCached.splice(index, 1)\r\n\t\t\t}\r\n\t\t\tif (change.action === INSERTION) {\r\n\t\t\t\tvar dummy = $document.createElement(\"div\")\r\n\t\t\t\tdummy.key = data[index].attrs.key\r\n\t\t\t\tinsertNode(parentElement, dummy, index)\r\n\t\t\t\tnewCached.splice(index, 0, {\r\n\t\t\t\t\tattrs: {key: data[index].attrs.key},\r\n\t\t\t\t\tnodes: [dummy]\r\n\t\t\t\t})\r\n\t\t\t\tnewCached.nodes[index] = dummy\r\n\t\t\t}\r\n\r\n\t\t\tif (change.action === MOVE) {\r\n\t\t\t\tvar changeElement = change.element\r\n\t\t\t\tvar maybeChanged = parentElement.childNodes[index]\r\n\t\t\t\tif (maybeChanged !== changeElement && changeElement !== null) {\r\n\t\t\t\t\tparentElement.insertBefore(changeElement,\r\n\t\t\t\t\t\tmaybeChanged || null)\r\n\t\t\t\t}\r\n\t\t\t\tnewCached[index] = cached[change.from]\r\n\t\t\t\tnewCached.nodes[index] = changeElement\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\treturn newCached\r\n\t}\r\n\r\n\tfunction diffKeys(data, cached, existing, parentElement) {\r\n\t\tvar keysDiffer = data.length !== cached.length\r\n\r\n\t\tif (!keysDiffer) {\r\n\t\t\tforKeys(data, function (attrs, i) {\r\n\t\t\t\tvar cachedCell = cached[i]\r\n\t\t\t\treturn keysDiffer = cachedCell &&\r\n\t\t\t\t\tcachedCell.attrs &&\r\n\t\t\t\t\tcachedCell.attrs.key !== attrs.key\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tif (keysDiffer) {\r\n\t\t\treturn handleKeysDiffer(data, existing, cached, parentElement)\r\n\t\t} else {\r\n\t\t\treturn cached\r\n\t\t}\r\n\t}\r\n\r\n\tfunction diffArray(data, cached, nodes) {\r\n\t\t// diff the array itself\r\n\r\n\t\t// update the list of DOM nodes by collecting the nodes from each item\r\n\t\tforEach(data, function (_, i) {\r\n\t\t\tif (cached[i] != null) nodes.push.apply(nodes, cached[i].nodes)\r\n\t\t})\r\n\t\t// remove items from the end of the array if the new array is shorter\r\n\t\t// than the old one. if errors ever happen here, the issue is most\r\n\t\t// likely a bug in the construction of the `cached` data structure\r\n\t\t// somewhere earlier in the program\r\n\t\tforEach(cached.nodes, function (node, i) {\r\n\t\t\tif (node.parentNode != null && nodes.indexOf(node) < 0) {\r\n\t\t\t\tclear([node], [cached[i]])\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tif (data.length < cached.length) cached.length = data.length\r\n\t\tcached.nodes = nodes\r\n\t}\r\n\r\n\tfunction buildArrayKeys(data) {\r\n\t\tvar guid = 0\r\n\t\tforKeys(data, function () {\r\n\t\t\tforEach(data, function (attrs) {\r\n\t\t\t\tif ((attrs = attrs && attrs.attrs) && attrs.key == null) {\r\n\t\t\t\t\tattrs.key = \"__mithril__\" + guid++\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\treturn 1\r\n\t\t})\r\n\t}\r\n\r\n\tfunction isDifferentEnough(data, cached, dataAttrKeys) {\r\n\t\tif (data.tag !== cached.tag) return true\r\n\r\n\t\tif (dataAttrKeys.sort().join() !==\r\n\t\t\t\tObject.keys(cached.attrs).sort().join()) {\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\tif (data.attrs.id !== cached.attrs.id) {\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\tif (data.attrs.key !== cached.attrs.key) {\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\tif (m.redraw.strategy() === \"all\") {\r\n\t\t\treturn !cached.configContext || cached.configContext.retain !== true\r\n\t\t}\r\n\r\n\t\tif (m.redraw.strategy() === \"diff\") {\r\n\t\t\treturn cached.configContext && cached.configContext.retain === false\r\n\t\t}\r\n\r\n\t\treturn false\r\n\t}\r\n\r\n\tfunction maybeRecreateObject(data, cached, dataAttrKeys) {\r\n\t\t// if an element is different enough from the one in cache, recreate it\r\n\t\tif (isDifferentEnough(data, cached, dataAttrKeys)) {\r\n\t\t\tif (cached.nodes.length) clear(cached.nodes)\r\n\r\n\t\t\tif (cached.configContext &&\r\n\t\t\t\t\tisFunction(cached.configContext.onunload)) {\r\n\t\t\t\tcached.configContext.onunload()\r\n\t\t\t}\r\n\r\n\t\t\tif (cached.controllers) {\r\n\t\t\t\tforEach(cached.controllers, function (controller) {\r\n\t\t\t\t\tif (controller.onunload) controller.onunload({preventDefault: noop});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getObjectNamespace(data, namespace) {\r\n\t\tif (data.attrs.xmlns) return data.attrs.xmlns\r\n\t\tif (data.tag === \"svg\") return \"http://www.w3.org/2000/svg\"\r\n\t\tif (data.tag === \"math\") return \"http://www.w3.org/1998/Math/MathML\"\r\n\t\treturn namespace\r\n\t}\r\n\r\n\tvar pendingRequests = 0\r\n\tm.startComputation = function () { pendingRequests++ }\r\n\tm.endComputation = function () {\r\n\t\tif (pendingRequests > 1) {\r\n\t\t\tpendingRequests--\r\n\t\t} else {\r\n\t\t\tpendingRequests = 0\r\n\t\t\tm.redraw()\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unloadCachedControllers(cached, views, controllers) {\r\n\t\tif (controllers.length) {\r\n\t\t\tcached.views = views\r\n\t\t\tcached.controllers = controllers\r\n\t\t\tforEach(controllers, function (controller) {\r\n\t\t\t\tif (controller.onunload && controller.onunload.$old) {\r\n\t\t\t\t\tcontroller.onunload = controller.onunload.$old\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (pendingRequests && controller.onunload) {\r\n\t\t\t\t\tvar onunload = controller.onunload\r\n\t\t\t\t\tcontroller.onunload = noop\r\n\t\t\t\t\tcontroller.onunload.$old = onunload\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tfunction scheduleConfigsToBeCalled(configs, data, node, isNew, cached) {\r\n\t\t// schedule configs to be called. They are called after `build` finishes\r\n\t\t// running\r\n\t\tif (isFunction(data.attrs.config)) {\r\n\t\t\tvar context = cached.configContext = cached.configContext || {}\r\n\r\n\t\t\t// bind\r\n\t\t\tconfigs.push(function () {\r\n\t\t\t\treturn data.attrs.config.call(data, node, !isNew, context,\r\n\t\t\t\t\tcached)\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tfunction buildUpdatedNode(\r\n\t\tcached,\r\n\t\tdata,\r\n\t\teditable,\r\n\t\thasKeys,\r\n\t\tnamespace,\r\n\t\tviews,\r\n\t\tconfigs,\r\n\t\tcontrollers\r\n\t) {\r\n\t\tvar node = cached.nodes[0]\r\n\r\n\t\tif (hasKeys) {\r\n\t\t\tsetAttributes(node, data.tag, data.attrs, cached.attrs, namespace)\r\n\t\t}\r\n\r\n\t\tcached.children = build(\r\n\t\t\tnode,\r\n\t\t\tdata.tag,\r\n\t\t\tundefined,\r\n\t\t\tundefined,\r\n\t\t\tdata.children,\r\n\t\t\tcached.children,\r\n\t\t\tfalse,\r\n\t\t\t0,\r\n\t\t\tdata.attrs.contenteditable ? node : editable,\r\n\t\t\tnamespace,\r\n\t\t\tconfigs\r\n\t\t)\r\n\r\n\t\tcached.nodes.intact = true\r\n\r\n\t\tif (controllers.length) {\r\n\t\t\tcached.views = views\r\n\t\t\tcached.controllers = controllers\r\n\t\t}\r\n\r\n\t\treturn node\r\n\t}\r\n\r\n\tfunction handleNonexistentNodes(data, parentElement, index) {\r\n\t\tvar nodes\r\n\t\tif (data.$trusted) {\r\n\t\t\tnodes = injectHTML(parentElement, index, data)\r\n\t\t} else {\r\n\t\t\tnodes = [$document.createTextNode(data)]\r\n\t\t\tif (!(parentElement.nodeName in voidElements)) {\r\n\t\t\t\tinsertNode(parentElement, nodes[0], index)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar cached\r\n\r\n\t\tif (typeof data === \"string\" ||\r\n\t\t\t\ttypeof data === \"number\" ||\r\n\t\t\t\ttypeof data === \"boolean\") {\r\n\t\t\tcached = new data.constructor(data)\r\n\t\t} else {\r\n\t\t\tcached = data\r\n\t\t}\r\n\r\n\t\tcached.nodes = nodes\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction reattachNodes(\r\n\t\tdata,\r\n\t\tcached,\r\n\t\tparentElement,\r\n\t\teditable,\r\n\t\tindex,\r\n\t\tparentTag\r\n\t) {\r\n\t\tvar nodes = cached.nodes\r\n\t\tif (!editable || editable !== $document.activeElement) {\r\n\t\t\tif (data.$trusted) {\r\n\t\t\t\tclear(nodes, cached)\r\n\t\t\t\tnodes = injectHTML(parentElement, index, data)\r\n\t\t\t} else if (parentTag === \"textarea\") {\r\n\t\t\t\t// <textarea> uses `value` instead of `nodeValue`.\r\n\t\t\t\tparentElement.value = data\r\n\t\t\t} else if (editable) {\r\n\t\t\t\t// contenteditable nodes use `innerHTML` instead of `nodeValue`.\r\n\t\t\t\teditable.innerHTML = data\r\n\t\t\t} else {\r\n\t\t\t\t// was a trusted string\r\n\t\t\t\tif (nodes[0].nodeType === 1 || nodes.length > 1 ||\r\n\t\t\t\t\t\t(nodes[0].nodeValue.trim &&\r\n\t\t\t\t\t\t\t!nodes[0].nodeValue.trim())) {\r\n\t\t\t\t\tclear(cached.nodes, cached)\r\n\t\t\t\t\tnodes = [$document.createTextNode(data)]\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinjectTextNode(parentElement, nodes[0], index, data)\r\n\t\t\t}\r\n\t\t}\r\n\t\tcached = new data.constructor(data)\r\n\t\tcached.nodes = nodes\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction handleTextNode(\r\n\t\tcached,\r\n\t\tdata,\r\n\t\tindex,\r\n\t\tparentElement,\r\n\t\tshouldReattach,\r\n\t\teditable,\r\n\t\tparentTag\r\n\t) {\r\n\t\tif (!cached.nodes.length) {\r\n\t\t\treturn handleNonexistentNodes(data, parentElement, index)\r\n\t\t} else if (cached.valueOf() !== data.valueOf() || shouldReattach) {\r\n\t\t\treturn reattachNodes(data, cached, parentElement, editable, index,\r\n\t\t\t\tparentTag)\r\n\t\t} else {\r\n\t\t\treturn (cached.nodes.intact = true, cached)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getSubArrayCount(item) {\r\n\t\tif (item.$trusted) {\r\n\t\t\t// fix offset of next element if item was a trusted string w/ more\r\n\t\t\t// than one html element\r\n\t\t\t// the first clause in the regexp matches elements\r\n\t\t\t// the second clause (after the pipe) matches text nodes\r\n\t\t\tvar match = item.match(/<[^\\/]|\\>\\s*[^<]/g)\r\n\t\t\tif (match != null) return match.length\r\n\t\t} else if (isArray(item)) {\r\n\t\t\treturn item.length\r\n\t\t}\r\n\t\treturn 1\r\n\t}\r\n\r\n\tfunction buildArray(\r\n\t\tdata,\r\n\t\tcached,\r\n\t\tparentElement,\r\n\t\tindex,\r\n\t\tparentTag,\r\n\t\tshouldReattach,\r\n\t\teditable,\r\n\t\tnamespace,\r\n\t\tconfigs\r\n\t) {\r\n\t\tdata = flatten(data)\r\n\t\tvar nodes = []\r\n\t\tvar intact = cached.length === data.length\r\n\t\tvar subArrayCount = 0\r\n\r\n\t\t// keys algorithm: sort elements without recreating them if keys are\r\n\t\t// present\r\n\t\t//\r\n\t\t// 1) create a map of all existing keys, and mark all for deletion\r\n\t\t// 2) add new keys to map and mark them for addition\r\n\t\t// 3) if key exists in new list, change action from deletion to a move\r\n\t\t// 4) for each key, handle its corresponding action as marked in\r\n\t\t//    previous steps\r\n\r\n\t\tvar existing = {}\r\n\t\tvar shouldMaintainIdentities = false\r\n\r\n\t\tforKeys(cached, function (attrs, i) {\r\n\t\t\tshouldMaintainIdentities = true\r\n\t\t\texisting[cached[i].attrs.key] = {action: DELETION, index: i}\r\n\t\t})\r\n\r\n\t\tbuildArrayKeys(data)\r\n\t\tif (shouldMaintainIdentities) {\r\n\t\t\tcached = diffKeys(data, cached, existing, parentElement)\r\n\t\t}\r\n\t\t// end key algorithm\r\n\r\n\t\tvar cacheCount = 0\r\n\t\t// faster explicitly written\r\n\t\tfor (var i = 0, len = data.length; i < len; i++) {\r\n\t\t\t// diff each item in the array\r\n\t\t\tvar item = build(\r\n\t\t\t\tparentElement,\r\n\t\t\t\tparentTag,\r\n\t\t\t\tcached,\r\n\t\t\t\tindex,\r\n\t\t\t\tdata[i],\r\n\t\t\t\tcached[cacheCount],\r\n\t\t\t\tshouldReattach,\r\n\t\t\t\tindex + subArrayCount || subArrayCount,\r\n\t\t\t\teditable,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tconfigs)\r\n\r\n\t\t\tif (item !== undefined) {\r\n\t\t\t\tintact = intact && item.nodes.intact\r\n\t\t\t\tsubArrayCount += getSubArrayCount(item)\r\n\t\t\t\tcached[cacheCount++] = item\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!intact) diffArray(data, cached, nodes)\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction makeCache(data, cached, index, parentIndex, parentCache) {\r\n\t\tif (cached != null) {\r\n\t\t\tif (type.call(cached) === type.call(data)) return cached\r\n\r\n\t\t\tif (parentCache && parentCache.nodes) {\r\n\t\t\t\tvar offset = index - parentIndex\r\n\t\t\t\tvar end = offset + (isArray(data) ? data : cached.nodes).length\r\n\t\t\t\tclear(\r\n\t\t\t\t\tparentCache.nodes.slice(offset, end),\r\n\t\t\t\t\tparentCache.slice(offset, end))\r\n\t\t\t} else if (cached.nodes) {\r\n\t\t\t\tclear(cached.nodes, cached)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcached = new data.constructor()\r\n\t\t// if constructor creates a virtual dom element, use a blank object as\r\n\t\t// the base cached node instead of copying the virtual el (#277)\r\n\t\tif (cached.tag) cached = {}\r\n\t\tcached.nodes = []\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction constructNode(data, namespace) {\r\n\t\tif (data.attrs.is) {\r\n\t\t\tif (namespace == null) {\r\n\t\t\t\treturn $document.createElement(data.tag, data.attrs.is)\r\n\t\t\t} else {\r\n\t\t\t\treturn $document.createElementNS(namespace, data.tag,\r\n\t\t\t\t\tdata.attrs.is)\r\n\t\t\t}\r\n\t\t} else if (namespace == null) {\r\n\t\t\treturn $document.createElement(data.tag)\r\n\t\t} else {\r\n\t\t\treturn $document.createElementNS(namespace, data.tag)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction constructAttrs(data, node, namespace, hasKeys) {\r\n\t\tif (hasKeys) {\r\n\t\t\treturn setAttributes(node, data.tag, data.attrs, {}, namespace)\r\n\t\t} else {\r\n\t\t\treturn data.attrs\r\n\t\t}\r\n\t}\r\n\r\n\tfunction constructChildren(\r\n\t\tdata,\r\n\t\tnode,\r\n\t\tcached,\r\n\t\teditable,\r\n\t\tnamespace,\r\n\t\tconfigs\r\n\t) {\r\n\t\tif (data.children != null && data.children.length > 0) {\r\n\t\t\treturn build(\r\n\t\t\t\tnode,\r\n\t\t\t\tdata.tag,\r\n\t\t\t\tundefined,\r\n\t\t\t\tundefined,\r\n\t\t\t\tdata.children,\r\n\t\t\t\tcached.children,\r\n\t\t\t\ttrue,\r\n\t\t\t\t0,\r\n\t\t\t\tdata.attrs.contenteditable ? node : editable,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tconfigs)\r\n\t\t} else {\r\n\t\t\treturn data.children\r\n\t\t}\r\n\t}\r\n\r\n\tfunction reconstructCached(\r\n\t\tdata,\r\n\t\tattrs,\r\n\t\tchildren,\r\n\t\tnode,\r\n\t\tnamespace,\r\n\t\tviews,\r\n\t\tcontrollers\r\n\t) {\r\n\t\tvar cached = {\r\n\t\t\ttag: data.tag,\r\n\t\t\tattrs: attrs,\r\n\t\t\tchildren: children,\r\n\t\t\tnodes: [node]\r\n\t\t}\r\n\r\n\t\tunloadCachedControllers(cached, views, controllers)\r\n\r\n\t\tif (cached.children && !cached.children.nodes) {\r\n\t\t\tcached.children.nodes = []\r\n\t\t}\r\n\r\n\t\t// edge case: setting value on <select> doesn't work before children\r\n\t\t// exist, so set it again after children have been created\r\n\t\tif (data.tag === \"select\" && \"value\" in data.attrs) {\r\n\t\t\tsetAttributes(node, data.tag, {value: data.attrs.value}, {},\r\n\t\t\t\tnamespace)\r\n\t\t}\r\n\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction getController(views, view, cachedControllers, controller) {\r\n\t\tvar controllerIndex\r\n\r\n\t\tif (m.redraw.strategy() === \"diff\" && views) {\r\n\t\t\tcontrollerIndex = views.indexOf(view)\r\n\t\t} else {\r\n\t\t\tcontrollerIndex = -1\r\n\t\t}\r\n\r\n\t\tif (controllerIndex > -1) {\r\n\t\t\treturn cachedControllers[controllerIndex]\r\n\t\t} else if (isFunction(controller)) {\r\n\t\t\treturn new controller()\r\n\t\t} else {\r\n\t\t\treturn {}\r\n\t\t}\r\n\t}\r\n\r\n\tvar unloaders = []\r\n\r\n\tfunction updateLists(views, controllers, view, controller) {\r\n\t\tif (controller.onunload != null && unloaders.map(function(u) {return u.handler}).indexOf(controller.onunload) < 0) {\r\n\t\t\tunloaders.push({\r\n\t\t\t\tcontroller: controller,\r\n\t\t\t\thandler: controller.onunload\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tviews.push(view)\r\n\t\tcontrollers.push(controller)\r\n\t}\r\n\r\n\tvar forcing = false\r\n\tfunction checkView(data, view, cached, cachedControllers, controllers, views) {\r\n\t\tvar controller = getController(cached.views, view, cachedControllers, data.controller)\r\n\t\tvar key = data && data.attrs && data.attrs.key\r\n\t\tdata = pendingRequests === 0 || forcing || cachedControllers && cachedControllers.indexOf(controller) > -1 ? data.view(controller) : {tag: \"placeholder\"}\r\n\t\tif (data.subtree === \"retain\") return data;\r\n\t\tdata.attrs = data.attrs || {}\r\n\t\tdata.attrs.key = key\r\n\t\tupdateLists(views, controllers, view, controller)\r\n\t\treturn data\r\n\t}\r\n\r\n\tfunction markViews(data, cached, views, controllers) {\r\n\t\tvar cachedControllers = cached && cached.controllers\r\n\r\n\t\twhile (data.view != null) {\r\n\t\t\tdata = checkView(\r\n\t\t\t\tdata,\r\n\t\t\t\tdata.view.$original || data.view,\r\n\t\t\t\tcached,\r\n\t\t\t\tcachedControllers,\r\n\t\t\t\tcontrollers,\r\n\t\t\t\tviews)\r\n\t\t}\r\n\r\n\t\treturn data\r\n\t}\r\n\r\n\tfunction buildObject( // eslint-disable-line max-statements\r\n\t\tdata,\r\n\t\tcached,\r\n\t\teditable,\r\n\t\tparentElement,\r\n\t\tindex,\r\n\t\tshouldReattach,\r\n\t\tnamespace,\r\n\t\tconfigs\r\n\t) {\r\n\t\tvar views = []\r\n\t\tvar controllers = []\r\n\r\n\t\tdata = markViews(data, cached, views, controllers)\r\n\r\n\t\tif (data.subtree === \"retain\") return cached\r\n\r\n\t\tif (!data.tag && controllers.length) {\r\n\t\t\tthrow new Error(\"Component template must return a virtual \" +\r\n\t\t\t\t\"element, not an array, string, etc.\")\r\n\t\t}\r\n\r\n\t\tdata.attrs = data.attrs || {}\r\n\t\tcached.attrs = cached.attrs || {}\r\n\r\n\t\tvar dataAttrKeys = Object.keys(data.attrs)\r\n\t\tvar hasKeys = dataAttrKeys.length > (\"key\" in data.attrs ? 1 : 0)\r\n\r\n\t\tmaybeRecreateObject(data, cached, dataAttrKeys)\r\n\r\n\t\tif (!isString(data.tag)) return\r\n\r\n\t\tvar isNew = cached.nodes.length === 0\r\n\r\n\t\tnamespace = getObjectNamespace(data, namespace)\r\n\r\n\t\tvar node\r\n\t\tif (isNew) {\r\n\t\t\tnode = constructNode(data, namespace)\r\n\t\t\t// set attributes first, then create children\r\n\t\t\tvar attrs = constructAttrs(data, node, namespace, hasKeys)\r\n\r\n\t\t\tvar children = constructChildren(data, node, cached, editable,\r\n\t\t\t\tnamespace, configs)\r\n\r\n\t\t\tcached = reconstructCached(\r\n\t\t\t\tdata,\r\n\t\t\t\tattrs,\r\n\t\t\t\tchildren,\r\n\t\t\t\tnode,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tviews,\r\n\t\t\t\tcontrollers)\r\n\t\t} else {\r\n\t\t\tnode = buildUpdatedNode(\r\n\t\t\t\tcached,\r\n\t\t\t\tdata,\r\n\t\t\t\teditable,\r\n\t\t\t\thasKeys,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tviews,\r\n\t\t\t\tconfigs,\r\n\t\t\t\tcontrollers)\r\n\t\t}\r\n\r\n\t\tif (isNew || shouldReattach === true && node != null) {\r\n\t\t\tinsertNode(parentElement, node, index)\r\n\t\t}\r\n\r\n\t\t// The configs are called after `build` finishes running\r\n\t\tscheduleConfigsToBeCalled(configs, data, node, isNew, cached)\r\n\r\n\t\treturn cached\r\n\t}\r\n\r\n\tfunction build(\r\n\t\tparentElement,\r\n\t\tparentTag,\r\n\t\tparentCache,\r\n\t\tparentIndex,\r\n\t\tdata,\r\n\t\tcached,\r\n\t\tshouldReattach,\r\n\t\tindex,\r\n\t\teditable,\r\n\t\tnamespace,\r\n\t\tconfigs\r\n\t) {\r\n\t\t/*\r\n\t\t * `build` is a recursive function that manages creation/diffing/removal\r\n\t\t * of DOM elements based on comparison between `data` and `cached` the\r\n\t\t * diff algorithm can be summarized as this:\r\n\t\t *\r\n\t\t * 1 - compare `data` and `cached`\r\n\t\t * 2 - if they are different, copy `data` to `cached` and update the DOM\r\n\t\t *     based on what the difference is\r\n\t\t * 3 - recursively apply this algorithm for every array and for the\r\n\t\t *     children of every virtual element\r\n\t\t *\r\n\t\t * The `cached` data structure is essentially the same as the previous\r\n\t\t * redraw's `data` data structure, with a few additions:\r\n\t\t * - `cached` always has a property called `nodes`, which is a list of\r\n\t\t *    DOM elements that correspond to the data represented by the\r\n\t\t *    respective virtual element\r\n\t\t * - in order to support attaching `nodes` as a property of `cached`,\r\n\t\t *    `cached` is *always* a non-primitive object, i.e. if the data was\r\n\t\t *    a string, then cached is a String instance. If data was `null` or\r\n\t\t *    `undefined`, cached is `new String(\"\")`\r\n\t\t * - `cached also has a `configContext` property, which is the state\r\n\t\t *    storage object exposed by config(element, isInitialized, context)\r\n\t\t * - when `cached` is an Object, it represents a virtual element; when\r\n\t\t *    it's an Array, it represents a list of elements; when it's a\r\n\t\t *    String, Number or Boolean, it represents a text node\r\n\t\t *\r\n\t\t * `parentElement` is a DOM element used for W3C DOM API calls\r\n\t\t * `parentTag` is only used for handling a corner case for textarea\r\n\t\t * values\r\n\t\t * `parentCache` is used to remove nodes in some multi-node cases\r\n\t\t * `parentIndex` and `index` are used to figure out the offset of nodes.\r\n\t\t * They're artifacts from before arrays started being flattened and are\r\n\t\t * likely refactorable\r\n\t\t * `data` and `cached` are, respectively, the new and old nodes being\r\n\t\t * diffed\r\n\t\t * `shouldReattach` is a flag indicating whether a parent node was\r\n\t\t * recreated (if so, and if this node is reused, then this node must\r\n\t\t * reattach itself to the new parent)\r\n\t\t * `editable` is a flag that indicates whether an ancestor is\r\n\t\t * contenteditable\r\n\t\t * `namespace` indicates the closest HTML namespace as it cascades down\r\n\t\t * from an ancestor\r\n\t\t * `configs` is a list of config functions to run after the topmost\r\n\t\t * `build` call finishes running\r\n\t\t *\r\n\t\t * there's logic that relies on the assumption that null and undefined\r\n\t\t * data are equivalent to empty strings\r\n\t\t * - this prevents lifecycle surprises from procedural helpers that mix\r\n\t\t *   implicit and explicit return statements (e.g.\r\n\t\t *   function foo() {if (cond) return m(\"div\")}\r\n\t\t * - it simplifies diffing code\r\n\t\t */\r\n\t\tdata = dataToString(data)\r\n\t\tif (data.subtree === \"retain\") return cached\r\n\t\tcached = makeCache(data, cached, index, parentIndex, parentCache)\r\n\r\n\t\tif (isArray(data)) {\r\n\t\t\treturn buildArray(\r\n\t\t\t\tdata,\r\n\t\t\t\tcached,\r\n\t\t\t\tparentElement,\r\n\t\t\t\tindex,\r\n\t\t\t\tparentTag,\r\n\t\t\t\tshouldReattach,\r\n\t\t\t\teditable,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tconfigs)\r\n\t\t} else if (data != null && isObject(data)) {\r\n\t\t\treturn buildObject(\r\n\t\t\t\tdata,\r\n\t\t\t\tcached,\r\n\t\t\t\teditable,\r\n\t\t\t\tparentElement,\r\n\t\t\t\tindex,\r\n\t\t\t\tshouldReattach,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tconfigs)\r\n\t\t} else if (!isFunction(data)) {\r\n\t\t\treturn handleTextNode(\r\n\t\t\t\tcached,\r\n\t\t\t\tdata,\r\n\t\t\t\tindex,\r\n\t\t\t\tparentElement,\r\n\t\t\t\tshouldReattach,\r\n\t\t\t\teditable,\r\n\t\t\t\tparentTag)\r\n\t\t} else {\r\n\t\t\treturn cached\r\n\t\t}\r\n\t}\r\n\r\n\tfunction sortChanges(a, b) {\r\n\t\treturn a.action - b.action || a.index - b.index\r\n\t}\r\n\r\n\tfunction copyStyleAttrs(node, dataAttr, cachedAttr) {\r\n\t\tfor (var rule in dataAttr) if (hasOwn.call(dataAttr, rule)) {\r\n\t\t\tif (cachedAttr == null || cachedAttr[rule] !== dataAttr[rule]) {\r\n\t\t\t\tnode.style[rule] = dataAttr[rule]\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (rule in cachedAttr) if (hasOwn.call(cachedAttr, rule)) {\r\n\t\t\tif (!hasOwn.call(dataAttr, rule)) node.style[rule] = \"\"\r\n\t\t}\r\n\t}\r\n\r\n\tvar shouldUseSetAttribute = {\r\n\t\tlist: 1,\r\n\t\tstyle: 1,\r\n\t\tform: 1,\r\n\t\ttype: 1,\r\n\t\twidth: 1,\r\n\t\theight: 1\r\n\t}\r\n\r\n\tfunction setSingleAttr(\r\n\t\tnode,\r\n\t\tattrName,\r\n\t\tdataAttr,\r\n\t\tcachedAttr,\r\n\t\ttag,\r\n\t\tnamespace\r\n\t) {\r\n\t\tif (attrName === \"config\" || attrName === \"key\") {\r\n\t\t\t// `config` isn't a real attribute, so ignore it\r\n\t\t\treturn true\r\n\t\t} else if (isFunction(dataAttr) && attrName.slice(0, 2) === \"on\") {\r\n\t\t\t// hook event handlers to the auto-redrawing system\r\n\t\t\tnode[attrName] = autoredraw(dataAttr, node)\r\n\t\t} else if (attrName === \"style\" && dataAttr != null &&\r\n\t\t\t\tisObject(dataAttr)) {\r\n\t\t\t// handle `style: {...}`\r\n\t\t\tcopyStyleAttrs(node, dataAttr, cachedAttr)\r\n\t\t} else if (namespace != null) {\r\n\t\t\t// handle SVG\r\n\t\t\tif (attrName === \"href\") {\r\n\t\t\t\tnode.setAttributeNS(\"http://www.w3.org/1999/xlink\",\r\n\t\t\t\t\t\"href\", dataAttr)\r\n\t\t\t} else {\r\n\t\t\t\tnode.setAttribute(\r\n\t\t\t\t\tattrName === \"className\" ? \"class\" : attrName,\r\n\t\t\t\t\tdataAttr)\r\n\t\t\t}\r\n\t\t} else if (attrName in node && !shouldUseSetAttribute[attrName]) {\r\n\t\t\t// handle cases that are properties (but ignore cases where we\r\n\t\t\t// should use setAttribute instead)\r\n\t\t\t//\r\n\t\t\t// - list and form are typically used as strings, but are DOM\r\n\t\t\t//   element references in js\r\n\t\t\t//\r\n\t\t\t// - when using CSS selectors (e.g. `m(\"[style='']\")`), style is\r\n\t\t\t//   used as a string, but it's an object in js\r\n\t\t\t//\r\n\t\t\t// #348 don't set the value if not needed - otherwise, cursor\r\n\t\t\t// placement breaks in Chrome\r\n\t\t\ttry {\r\n\t\t\t\tif (tag !== \"input\" || node[attrName] !== dataAttr) {\r\n\t\t\t\t\tnode[attrName] = dataAttr\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\tnode.setAttribute(attrName, dataAttr)\r\n\t\t\t}\r\n\t\t}\r\n\t\telse node.setAttribute(attrName, dataAttr)\r\n\t}\r\n\r\n\tfunction trySetAttr(\r\n\t\tnode,\r\n\t\tattrName,\r\n\t\tdataAttr,\r\n\t\tcachedAttr,\r\n\t\tcachedAttrs,\r\n\t\ttag,\r\n\t\tnamespace\r\n\t) {\r\n\t\tif (!(attrName in cachedAttrs) || (cachedAttr !== dataAttr)) {\r\n\t\t\tcachedAttrs[attrName] = dataAttr\r\n\t\t\ttry {\r\n\t\t\t\treturn setSingleAttr(\r\n\t\t\t\t\tnode,\r\n\t\t\t\t\tattrName,\r\n\t\t\t\t\tdataAttr,\r\n\t\t\t\t\tcachedAttr,\r\n\t\t\t\t\ttag,\r\n\t\t\t\t\tnamespace)\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// swallow IE's invalid argument errors to mimic HTML's\r\n\t\t\t\t// fallback-to-doing-nothing-on-invalid-attributes behavior\r\n\t\t\t\tif (e.message.indexOf(\"Invalid argument\") < 0) throw e\r\n\t\t\t}\r\n\t\t} else if (attrName === \"value\" && tag === \"input\" &&\r\n\t\t\t\tnode.value !== dataAttr) {\r\n\t\t\t// #348 dataAttr may not be a string, so use loose comparison\r\n\t\t\tnode.value = dataAttr\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setAttributes(node, tag, dataAttrs, cachedAttrs, namespace) {\r\n\t\tfor (var attrName in dataAttrs) if (hasOwn.call(dataAttrs, attrName)) {\r\n\t\t\tif (trySetAttr(\r\n\t\t\t\t\tnode,\r\n\t\t\t\t\tattrName,\r\n\t\t\t\t\tdataAttrs[attrName],\r\n\t\t\t\t\tcachedAttrs[attrName],\r\n\t\t\t\t\tcachedAttrs,\r\n\t\t\t\t\ttag,\r\n\t\t\t\t\tnamespace)) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cachedAttrs\r\n\t}\r\n\r\n\tfunction clear(nodes, cached) {\r\n\t\tfor (var i = nodes.length - 1; i > -1; i--) {\r\n\t\t\tif (nodes[i] && nodes[i].parentNode) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tnodes[i].parentNode.removeChild(nodes[i])\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\t/* eslint-disable max-len */\r\n\t\t\t\t\t// ignore if this fails due to order of events (see\r\n\t\t\t\t\t// http://stackoverflow.com/questions/21926083/failed-to-execute-removechild-on-node)\r\n\t\t\t\t\t/* eslint-enable max-len */\r\n\t\t\t\t}\r\n\t\t\t\tcached = [].concat(cached)\r\n\t\t\t\tif (cached[i]) unload(cached[i])\r\n\t\t\t}\r\n\t\t}\r\n\t\t// release memory if nodes is an array. This check should fail if nodes\r\n\t\t// is a NodeList (see loop above)\r\n\t\tif (nodes.length) {\r\n\t\t\tnodes.length = 0\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unload(cached) {\r\n\t\tif (cached.configContext && isFunction(cached.configContext.onunload)) {\r\n\t\t\tcached.configContext.onunload()\r\n\t\t\tcached.configContext.onunload = null\r\n\t\t}\r\n\t\tif (cached.controllers) {\r\n\t\t\tforEach(cached.controllers, function (controller) {\r\n\t\t\t\tif (isFunction(controller.onunload)) {\r\n\t\t\t\t\tcontroller.onunload({preventDefault: noop})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\tif (cached.children) {\r\n\t\t\tif (isArray(cached.children)) forEach(cached.children, unload)\r\n\t\t\telse if (cached.children.tag) unload(cached.children)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction appendTextFragment(parentElement, data) {\r\n\t\ttry {\r\n\t\t\tparentElement.appendChild(\r\n\t\t\t\t$document.createRange().createContextualFragment(data))\r\n\t\t} catch (e) {\r\n\t\t\tparentElement.insertAdjacentHTML(\"beforeend\", data)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction injectHTML(parentElement, index, data) {\r\n\t\tvar nextSibling = parentElement.childNodes[index]\r\n\t\tif (nextSibling) {\r\n\t\t\tvar isElement = nextSibling.nodeType !== 1\r\n\t\t\tvar placeholder = $document.createElement(\"span\")\r\n\t\t\tif (isElement) {\r\n\t\t\t\tparentElement.insertBefore(placeholder, nextSibling || null)\r\n\t\t\t\tplaceholder.insertAdjacentHTML(\"beforebegin\", data)\r\n\t\t\t\tparentElement.removeChild(placeholder)\r\n\t\t\t} else {\r\n\t\t\t\tnextSibling.insertAdjacentHTML(\"beforebegin\", data)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tappendTextFragment(parentElement, data)\r\n\t\t}\r\n\r\n\t\tvar nodes = []\r\n\r\n\t\twhile (parentElement.childNodes[index] !== nextSibling) {\r\n\t\t\tnodes.push(parentElement.childNodes[index])\r\n\t\t\tindex++\r\n\t\t}\r\n\r\n\t\treturn nodes\r\n\t}\r\n\r\n\tfunction autoredraw(callback, object) {\r\n\t\treturn function (e) {\r\n\t\t\te = e || event\r\n\t\t\tm.redraw.strategy(\"diff\")\r\n\t\t\tm.startComputation()\r\n\t\t\ttry {\r\n\t\t\t\treturn callback.call(object, e)\r\n\t\t\t} finally {\r\n\t\t\t\tendFirstComputation()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvar html\r\n\tvar documentNode = {\r\n\t\tappendChild: function (node) {\r\n\t\t\tif (html === undefined) html = $document.createElement(\"html\")\r\n\t\t\tif ($document.documentElement &&\r\n\t\t\t\t\t$document.documentElement !== node) {\r\n\t\t\t\t$document.replaceChild(node, $document.documentElement)\r\n\t\t\t} else {\r\n\t\t\t\t$document.appendChild(node)\r\n\t\t\t}\r\n\r\n\t\t\tthis.childNodes = $document.childNodes\r\n\t\t},\r\n\r\n\t\tinsertBefore: function (node) {\r\n\t\t\tthis.appendChild(node)\r\n\t\t},\r\n\r\n\t\tchildNodes: []\r\n\t}\r\n\r\n\tvar nodeCache = []\r\n\tvar cellCache = {}\r\n\r\n\tm.render = function (root, cell, forceRecreation) {\r\n\t\tif (!root) {\r\n\t\t\tthrow new Error(\"Ensure the DOM element being passed to \" +\r\n\t\t\t\t\"m.route/m.mount/m.render is not undefined.\")\r\n\t\t}\r\n\t\tvar configs = []\r\n\t\tvar id = getCellCacheKey(root)\r\n\t\tvar isDocumentRoot = root === $document\r\n\t\tvar node\r\n\r\n\t\tif (isDocumentRoot || root === $document.documentElement) {\r\n\t\t\tnode = documentNode\r\n\t\t} else {\r\n\t\t\tnode = root\r\n\t\t}\r\n\r\n\t\tif (isDocumentRoot && cell.tag !== \"html\") {\r\n\t\t\tcell = {tag: \"html\", attrs: {}, children: cell}\r\n\t\t}\r\n\r\n\t\tif (cellCache[id] === undefined) clear(node.childNodes)\r\n\t\tif (forceRecreation === true) reset(root)\r\n\r\n\t\tcellCache[id] = build(\r\n\t\t\tnode,\r\n\t\t\tnull,\r\n\t\t\tundefined,\r\n\t\t\tundefined,\r\n\t\t\tcell,\r\n\t\t\tcellCache[id],\r\n\t\t\tfalse,\r\n\t\t\t0,\r\n\t\t\tnull,\r\n\t\t\tundefined,\r\n\t\t\tconfigs)\r\n\r\n\t\tforEach(configs, function (config) { config() })\r\n\t}\r\n\r\n\tfunction getCellCacheKey(element) {\r\n\t\tvar index = nodeCache.indexOf(element)\r\n\t\treturn index < 0 ? nodeCache.push(element) - 1 : index\r\n\t}\r\n\r\n\tm.trust = function (value) {\r\n\t\tvalue = new String(value) // eslint-disable-line no-new-wrappers\r\n\t\tvalue.$trusted = true\r\n\t\treturn value\r\n\t}\r\n\r\n\tfunction gettersetter(store) {\r\n\t\tfunction prop() {\r\n\t\t\tif (arguments.length) store = arguments[0]\r\n\t\t\treturn store\r\n\t\t}\r\n\r\n\t\tprop.toJSON = function () {\r\n\t\t\treturn store\r\n\t\t}\r\n\r\n\t\treturn prop\r\n\t}\r\n\r\n\tm.prop = function (store) {\r\n\t\tif ((store != null && isObject(store) || isFunction(store)) &&\r\n\t\t\t\tisFunction(store.then)) {\r\n\t\t\treturn propify(store)\r\n\t\t}\r\n\r\n\t\treturn gettersetter(store)\r\n\t}\r\n\r\n\tvar roots = []\r\n\tvar components = []\r\n\tvar controllers = []\r\n\tvar lastRedrawId = null\r\n\tvar lastRedrawCallTime = 0\r\n\tvar computePreRedrawHook = null\r\n\tvar computePostRedrawHook = null\r\n\tvar topComponent\r\n\tvar FRAME_BUDGET = 16 // 60 frames per second = 1 call per 16 ms\r\n\r\n\tfunction parameterize(component, args) {\r\n\t\tfunction controller() {\r\n\t\t\t/* eslint-disable no-invalid-this */\r\n\t\t\treturn (component.controller || noop).apply(this, args) || this\r\n\t\t\t/* eslint-enable no-invalid-this */\r\n\t\t}\r\n\r\n\t\tif (component.controller) {\r\n\t\t\tcontroller.prototype = component.controller.prototype\r\n\t\t}\r\n\r\n\t\tfunction view(ctrl) {\r\n\t\t\tvar currentArgs = [ctrl].concat(args)\r\n\t\t\tfor (var i = 1; i < arguments.length; i++) {\r\n\t\t\t\tcurrentArgs.push(arguments[i])\r\n\t\t\t}\r\n\r\n\t\t\treturn component.view.apply(component, currentArgs)\r\n\t\t}\r\n\r\n\t\tview.$original = component.view\r\n\t\tvar output = {controller: controller, view: view}\r\n\t\tif (args[0] && args[0].key != null) output.attrs = {key: args[0].key}\r\n\t\treturn output\r\n\t}\r\n\r\n\tm.component = function (component) {\r\n\t\tvar args = [].slice.call(arguments, 1)\r\n\r\n\t\treturn parameterize(component, args)\r\n\t}\r\n\r\n\tfunction checkPrevented(component, root, index, isPrevented) {\r\n\t\tif (!isPrevented) {\r\n\t\t\tm.redraw.strategy(\"all\")\r\n\t\t\tm.startComputation()\r\n\t\t\troots[index] = root\r\n\t\t\tvar currentComponent\r\n\r\n\t\t\tif (component) {\r\n\t\t\t\tcurrentComponent = topComponent = component\r\n\t\t\t} else {\r\n\t\t\t\tcurrentComponent = topComponent = component = {controller: noop}\r\n\t\t\t}\r\n\r\n\t\t\tvar controller = new (component.controller || noop)()\r\n\r\n\t\t\t// controllers may call m.mount recursively (via m.route redirects,\r\n\t\t\t// for example)\r\n\t\t\t// this conditional ensures only the last recursive m.mount call is\r\n\t\t\t// applied\r\n\t\t\tif (currentComponent === topComponent) {\r\n\t\t\t\tcontrollers[index] = controller\r\n\t\t\t\tcomponents[index] = component\r\n\t\t\t}\r\n\t\t\tendFirstComputation()\r\n\t\t\tif (component === null) {\r\n\t\t\t\tremoveRootElement(root, index)\r\n\t\t\t}\r\n\t\t\treturn controllers[index]\r\n\t\t} else if (component == null) {\r\n\t\t\tremoveRootElement(root, index)\r\n\t\t}\r\n\t}\r\n\r\n\tm.mount = m.module = function (root, component) {\r\n\t\tif (!root) {\r\n\t\t\tthrow new Error(\"Please ensure the DOM element exists before \" +\r\n\t\t\t\t\"rendering a template into it.\")\r\n\t\t}\r\n\r\n\t\tvar index = roots.indexOf(root)\r\n\t\tif (index < 0) index = roots.length\r\n\r\n\t\tvar isPrevented = false\r\n\t\tvar event = {\r\n\t\t\tpreventDefault: function () {\r\n\t\t\t\tisPrevented = true\r\n\t\t\t\tcomputePreRedrawHook = computePostRedrawHook = null\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tforEach(unloaders, function (unloader) {\r\n\t\t\tunloader.handler.call(unloader.controller, event)\r\n\t\t\tunloader.controller.onunload = null\r\n\t\t})\r\n\r\n\t\tif (isPrevented) {\r\n\t\t\tforEach(unloaders, function (unloader) {\r\n\t\t\t\tunloader.controller.onunload = unloader.handler\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\tunloaders = []\r\n\t\t}\r\n\r\n\t\tif (controllers[index] && isFunction(controllers[index].onunload)) {\r\n\t\t\tcontrollers[index].onunload(event)\r\n\t\t}\r\n\r\n\t\treturn checkPrevented(component, root, index, isPrevented)\r\n\t}\r\n\r\n\tfunction removeRootElement(root, index) {\r\n\t\troots.splice(index, 1)\r\n\t\tcontrollers.splice(index, 1)\r\n\t\tcomponents.splice(index, 1)\r\n\t\treset(root)\r\n\t\tnodeCache.splice(getCellCacheKey(root), 1)\r\n\t}\r\n\r\n\tvar redrawing = false\r\n\tm.redraw = function (force) {\r\n\t\tif (redrawing) return\r\n\t\tredrawing = true\r\n\t\tif (force) forcing = true\r\n\r\n\t\ttry {\r\n\t\t\t// lastRedrawId is a positive number if a second redraw is requested\r\n\t\t\t// before the next animation frame\r\n\t\t\t// lastRedrawID is null if it's the first redraw and not an event\r\n\t\t\t// handler\r\n\t\t\tif (lastRedrawId && !force) {\r\n\t\t\t\t// when setTimeout: only reschedule redraw if time between now\r\n\t\t\t\t// and previous redraw is bigger than a frame, otherwise keep\r\n\t\t\t\t// currently scheduled timeout\r\n\t\t\t\t// when rAF: always reschedule redraw\r\n\t\t\t\tif ($requestAnimationFrame === global.requestAnimationFrame ||\r\n\t\t\t\t\t\tnew Date() - lastRedrawCallTime > FRAME_BUDGET) {\r\n\t\t\t\t\tif (lastRedrawId > 0) $cancelAnimationFrame(lastRedrawId)\r\n\t\t\t\t\tlastRedrawId = $requestAnimationFrame(redraw, FRAME_BUDGET)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tredraw()\r\n\t\t\t\tlastRedrawId = $requestAnimationFrame(function () {\r\n\t\t\t\t\tlastRedrawId = null\r\n\t\t\t\t}, FRAME_BUDGET)\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tredrawing = forcing = false\r\n\t\t}\r\n\t}\r\n\r\n\tm.redraw.strategy = m.prop()\r\n\tfunction redraw() {\r\n\t\tif (computePreRedrawHook) {\r\n\t\t\tcomputePreRedrawHook()\r\n\t\t\tcomputePreRedrawHook = null\r\n\t\t}\r\n\t\tforEach(roots, function (root, i) {\r\n\t\t\tvar component = components[i]\r\n\t\t\tif (controllers[i]) {\r\n\t\t\t\tvar args = [controllers[i]]\r\n\t\t\t\tm.render(root,\r\n\t\t\t\t\tcomponent.view ? component.view(controllers[i], args) : \"\")\r\n\t\t\t}\r\n\t\t})\r\n\t\t// after rendering within a routed context, we need to scroll back to\r\n\t\t// the top, and fetch the document title for history.pushState\r\n\t\tif (computePostRedrawHook) {\r\n\t\t\tcomputePostRedrawHook()\r\n\t\t\tcomputePostRedrawHook = null\r\n\t\t}\r\n\t\tlastRedrawId = null\r\n\t\tlastRedrawCallTime = new Date()\r\n\t\tm.redraw.strategy(\"diff\")\r\n\t}\r\n\r\n\tfunction endFirstComputation() {\r\n\t\tif (m.redraw.strategy() === \"none\") {\r\n\t\t\tpendingRequests--\r\n\t\t\tm.redraw.strategy(\"diff\")\r\n\t\t} else {\r\n\t\t\tm.endComputation()\r\n\t\t}\r\n\t}\r\n\r\n\tm.withAttr = function (prop, withAttrCallback, callbackThis) {\r\n\t\treturn function (e) {\r\n\t\t\te = e || event\r\n\t\t\t/* eslint-disable no-invalid-this */\r\n\t\t\tvar currentTarget = e.currentTarget || this\r\n\t\t\tvar _this = callbackThis || this\r\n\t\t\t/* eslint-enable no-invalid-this */\r\n\t\t\tvar target = prop in currentTarget ?\r\n\t\t\t\tcurrentTarget[prop] :\r\n\t\t\t\tcurrentTarget.getAttribute(prop)\r\n\t\t\twithAttrCallback.call(_this, target)\r\n\t\t}\r\n\t}\r\n\r\n\t// routing\r\n\tvar modes = {pathname: \"\", hash: \"#\", search: \"?\"}\r\n\tvar redirect = noop\r\n\tvar isDefaultRoute = false\r\n\tvar routeParams, currentRoute\r\n\r\n\tm.route = function (root, arg1, arg2, vdom) { // eslint-disable-line\r\n\t\t// m.route()\r\n\t\tif (arguments.length === 0) return currentRoute\r\n\t\t// m.route(el, defaultRoute, routes)\r\n\t\tif (arguments.length === 3 && isString(arg1)) {\r\n\t\t\tredirect = function (source) {\r\n\t\t\t\tvar path = currentRoute = normalizeRoute(source)\r\n\t\t\t\tif (!routeByValue(root, arg2, path)) {\r\n\t\t\t\t\tif (isDefaultRoute) {\r\n\t\t\t\t\t\tthrow new Error(\"Ensure the default route matches \" +\r\n\t\t\t\t\t\t\t\"one of the routes defined in m.route\")\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tisDefaultRoute = true\r\n\t\t\t\t\tm.route(arg1, true)\r\n\t\t\t\t\tisDefaultRoute = false\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar listener = m.route.mode === \"hash\" ?\r\n\t\t\t\t\"onhashchange\" :\r\n\t\t\t\t\"onpopstate\"\r\n\r\n\t\t\tglobal[listener] = function () {\r\n\t\t\t\tvar path = $location[m.route.mode]\r\n\t\t\t\tif (m.route.mode === \"pathname\") path += $location.search\r\n\t\t\t\tif (currentRoute !== normalizeRoute(path)) redirect(path)\r\n\t\t\t}\r\n\r\n\t\t\tcomputePreRedrawHook = setScroll\r\n\t\t\tglobal[listener]()\r\n\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// config: m.route\r\n\t\tif (root.addEventListener || root.attachEvent) {\r\n\t\t\tvar base = m.route.mode !== \"pathname\" ? $location.pathname : \"\"\r\n\t\t\troot.href = base + modes[m.route.mode] + vdom.attrs.href\r\n\t\t\tif (root.addEventListener) {\r\n\t\t\t\troot.removeEventListener(\"click\", routeUnobtrusive)\r\n\t\t\t\troot.addEventListener(\"click\", routeUnobtrusive)\r\n\t\t\t} else {\r\n\t\t\t\troot.detachEvent(\"onclick\", routeUnobtrusive)\r\n\t\t\t\troot.attachEvent(\"onclick\", routeUnobtrusive)\r\n\t\t\t}\r\n\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// m.route(route, params, shouldReplaceHistoryEntry)\r\n\t\tif (isString(root)) {\r\n\t\t\tvar oldRoute = currentRoute\r\n\t\t\tcurrentRoute = root\r\n\r\n\t\t\tvar args = arg1 || {}\r\n\t\t\tvar queryIndex = currentRoute.indexOf(\"?\")\r\n\t\t\tvar params\r\n\r\n\t\t\tif (queryIndex > -1) {\r\n\t\t\t\tparams = parseQueryString(currentRoute.slice(queryIndex + 1))\r\n\t\t\t} else {\r\n\t\t\t\tparams = {}\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i in args) if (hasOwn.call(args, i)) {\r\n\t\t\t\tparams[i] = args[i]\r\n\t\t\t}\r\n\r\n\t\t\tvar querystring = buildQueryString(params)\r\n\t\t\tvar currentPath\r\n\r\n\t\t\tif (queryIndex > -1) {\r\n\t\t\t\tcurrentPath = currentRoute.slice(0, queryIndex)\r\n\t\t\t} else {\r\n\t\t\t\tcurrentPath = currentRoute\r\n\t\t\t}\r\n\r\n\t\t\tif (querystring) {\r\n\t\t\t\tcurrentRoute = currentPath +\r\n\t\t\t\t\t(currentPath.indexOf(\"?\") === -1 ? \"?\" : \"&\") +\r\n\t\t\t\t\tquerystring\r\n\t\t\t}\r\n\r\n\t\t\tvar replaceHistory =\r\n\t\t\t\t(arguments.length === 3 ? arg2 : arg1) === true ||\r\n\t\t\t\toldRoute === root\r\n\r\n\t\t\tif (global.history.pushState) {\r\n\t\t\t\tvar method = replaceHistory ? \"replaceState\" : \"pushState\"\r\n\t\t\t\tcomputePreRedrawHook = setScroll\r\n\t\t\t\tcomputePostRedrawHook = function () {\r\n\t\t\t\t\tglobal.history[method](null, $document.title,\r\n\t\t\t\t\t\tmodes[m.route.mode] + currentRoute)\r\n\t\t\t\t}\r\n\t\t\t\tredirect(modes[m.route.mode] + currentRoute)\r\n\t\t\t} else {\r\n\t\t\t\t$location[m.route.mode] = currentRoute\r\n\t\t\t\tredirect(modes[m.route.mode] + currentRoute)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tm.route.param = function (key) {\r\n\t\tif (!routeParams) {\r\n\t\t\tthrow new Error(\"You must call m.route(element, defaultRoute, \" +\r\n\t\t\t\t\"routes) before calling m.route.param()\")\r\n\t\t}\r\n\r\n\t\tif (!key) {\r\n\t\t\treturn routeParams\r\n\t\t}\r\n\r\n\t\treturn routeParams[key]\r\n\t}\r\n\r\n\tm.route.mode = \"search\"\r\n\r\n\tfunction normalizeRoute(route) {\r\n\t\treturn route.slice(modes[m.route.mode].length)\r\n\t}\r\n\r\n\tfunction routeByValue(root, router, path) {\r\n\t\trouteParams = {}\r\n\r\n\t\tvar queryStart = path.indexOf(\"?\")\r\n\t\tif (queryStart !== -1) {\r\n\t\t\trouteParams = parseQueryString(\r\n\t\t\t\tpath.substr(queryStart + 1, path.length))\r\n\t\t\tpath = path.substr(0, queryStart)\r\n\t\t}\r\n\r\n\t\t// Get all routes and check if there's\r\n\t\t// an exact match for the current path\r\n\t\tvar keys = Object.keys(router)\r\n\t\tvar index = keys.indexOf(path)\r\n\r\n\t\tif (index !== -1){\r\n\t\t\tm.mount(root, router[keys [index]])\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\tfor (var route in router) if (hasOwn.call(router, route)) {\r\n\t\t\tif (route === path) {\r\n\t\t\t\tm.mount(root, router[route])\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\r\n\t\t\tvar matcher = new RegExp(\"^\" + route\r\n\t\t\t\t.replace(/:[^\\/]+?\\.{3}/g, \"(.*?)\")\r\n\t\t\t\t.replace(/:[^\\/]+/g, \"([^\\\\/]+)\") + \"\\/?$\")\r\n\r\n\t\t\tif (matcher.test(path)) {\r\n\t\t\t\t/* eslint-disable no-loop-func */\r\n\t\t\t\tpath.replace(matcher, function () {\r\n\t\t\t\t\tvar keys = route.match(/:[^\\/]+/g) || []\r\n\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\r\n\t\t\t\t\tforEach(keys, function (key, i) {\r\n\t\t\t\t\t\trouteParams[key.replace(/:|\\./g, \"\")] =\r\n\t\t\t\t\t\t\tdecodeURIComponent(values[i])\r\n\t\t\t\t\t})\r\n\t\t\t\t\tm.mount(root, router[route])\r\n\t\t\t\t})\r\n\t\t\t\t/* eslint-enable no-loop-func */\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction routeUnobtrusive(e) {\r\n\t\te = e || event\r\n\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\r\n\r\n\t\tif (e.preventDefault) {\r\n\t\t\te.preventDefault()\r\n\t\t} else {\r\n\t\t\te.returnValue = false\r\n\t\t}\r\n\r\n\t\tvar currentTarget = e.currentTarget || e.srcElement\r\n\t\tvar args\r\n\r\n\t\tif (m.route.mode === \"pathname\" && currentTarget.search) {\r\n\t\t\targs = parseQueryString(currentTarget.search.slice(1))\r\n\t\t} else {\r\n\t\t\targs = {}\r\n\t\t}\r\n\r\n\t\twhile (currentTarget && !/a/i.test(currentTarget.nodeName)) {\r\n\t\t\tcurrentTarget = currentTarget.parentNode\r\n\t\t}\r\n\r\n\t\t// clear pendingRequests because we want an immediate route change\r\n\t\tpendingRequests = 0\r\n\t\tm.route(currentTarget[m.route.mode]\r\n\t\t\t.slice(modes[m.route.mode].length), args)\r\n\t}\r\n\r\n\tfunction setScroll() {\r\n\t\tif (m.route.mode !== \"hash\" && $location.hash) {\r\n\t\t\t$location.hash = $location.hash\r\n\t\t} else {\r\n\t\t\tglobal.scrollTo(0, 0)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction buildQueryString(object, prefix) {\r\n\t\tvar duplicates = {}\r\n\t\tvar str = []\r\n\r\n\t\tfor (var prop in object) if (hasOwn.call(object, prop)) {\r\n\t\t\tvar key = prefix ? prefix + \"[\" + prop + \"]\" : prop\r\n\t\t\tvar value = object[prop]\r\n\r\n\t\t\tif (value === null) {\r\n\t\t\t\tstr.push(encodeURIComponent(key))\r\n\t\t\t} else if (isObject(value)) {\r\n\t\t\t\tstr.push(buildQueryString(value, key))\r\n\t\t\t} else if (isArray(value)) {\r\n\t\t\t\tvar keys = []\r\n\t\t\t\tduplicates[key] = duplicates[key] || {}\r\n\t\t\t\t/* eslint-disable no-loop-func */\r\n\t\t\t\tforEach(value, function (item) {\r\n\t\t\t\t\t/* eslint-enable no-loop-func */\r\n\t\t\t\t\tif (!duplicates[key][item]) {\r\n\t\t\t\t\t\tduplicates[key][item] = true\r\n\t\t\t\t\t\tkeys.push(encodeURIComponent(key) + \"=\" +\r\n\t\t\t\t\t\t\tencodeURIComponent(item))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tstr.push(keys.join(\"&\"))\r\n\t\t\t} else if (value !== undefined) {\r\n\t\t\t\tstr.push(encodeURIComponent(key) + \"=\" +\r\n\t\t\t\t\tencodeURIComponent(value))\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn str.join(\"&\")\r\n\t}\r\n\r\n\tfunction parseQueryString(str) {\r\n\t\tif (str === \"\" || str == null) return {}\r\n\t\tif (str.charAt(0) === \"?\") str = str.slice(1)\r\n\r\n\t\tvar pairs = str.split(\"&\")\r\n\t\tvar params = {}\r\n\r\n\t\tforEach(pairs, function (string) {\r\n\t\t\tvar pair = string.split(\"=\")\r\n\t\t\tvar key = decodeURIComponent(pair[0])\r\n\t\t\tvar value = pair.length === 2 ? decodeURIComponent(pair[1]) : null\r\n\t\t\tif (params[key] != null) {\r\n\t\t\t\tif (!isArray(params[key])) params[key] = [params[key]]\r\n\t\t\t\tparams[key].push(value)\r\n\t\t\t}\r\n\t\t\telse params[key] = value\r\n\t\t})\r\n\r\n\t\treturn params\r\n\t}\r\n\r\n\tm.route.buildQueryString = buildQueryString\r\n\tm.route.parseQueryString = parseQueryString\r\n\r\n\tfunction reset(root) {\r\n\t\tvar cacheKey = getCellCacheKey(root)\r\n\t\tclear(root.childNodes, cellCache[cacheKey])\r\n\t\tcellCache[cacheKey] = undefined\r\n\t}\r\n\r\n\tm.deferred = function () {\r\n\t\tvar deferred = new Deferred()\r\n\t\tdeferred.promise = propify(deferred.promise)\r\n\t\treturn deferred\r\n\t}\r\n\r\n\tfunction propify(promise, initialValue) {\r\n\t\tvar prop = m.prop(initialValue)\r\n\t\tpromise.then(prop)\r\n\t\tprop.then = function (resolve, reject) {\r\n\t\t\treturn propify(promise.then(resolve, reject), initialValue)\r\n\t\t}\r\n\r\n\t\tprop.catch = prop.then.bind(null, null)\r\n\t\treturn prop\r\n\t}\r\n\t// Promiz.mithril.js | Zolmeister | MIT\r\n\t// a modified version of Promiz.js, which does not conform to Promises/A+\r\n\t// for two reasons:\r\n\t//\r\n\t// 1) `then` callbacks are called synchronously (because setTimeout is too\r\n\t//    slow, and the setImmediate polyfill is too big\r\n\t//\r\n\t// 2) throwing subclasses of Error cause the error to be bubbled up instead\r\n\t//    of triggering rejection (because the spec does not account for the\r\n\t//    important use case of default browser error handling, i.e. message w/\r\n\t//    line number)\r\n\r\n\tvar RESOLVING = 1\r\n\tvar REJECTING = 2\r\n\tvar RESOLVED = 3\r\n\tvar REJECTED = 4\r\n\r\n\tfunction Deferred(onSuccess, onFailure) {\r\n\t\tvar self = this\r\n\t\tvar state = 0\r\n\t\tvar promiseValue = 0\r\n\t\tvar next = []\r\n\r\n\t\tself.promise = {}\r\n\r\n\t\tself.resolve = function (value) {\r\n\t\t\tif (!state) {\r\n\t\t\t\tpromiseValue = value\r\n\t\t\t\tstate = RESOLVING\r\n\r\n\t\t\t\tfire()\r\n\t\t\t}\r\n\r\n\t\t\treturn self\r\n\t\t}\r\n\r\n\t\tself.reject = function (value) {\r\n\t\t\tif (!state) {\r\n\t\t\t\tpromiseValue = value\r\n\t\t\t\tstate = REJECTING\r\n\r\n\t\t\t\tfire()\r\n\t\t\t}\r\n\r\n\t\t\treturn self\r\n\t\t}\r\n\r\n\t\tself.promise.then = function (onSuccess, onFailure) {\r\n\t\t\tvar deferred = new Deferred(onSuccess, onFailure)\r\n\r\n\t\t\tif (state === RESOLVED) {\r\n\t\t\t\tdeferred.resolve(promiseValue)\r\n\t\t\t} else if (state === REJECTED) {\r\n\t\t\t\tdeferred.reject(promiseValue)\r\n\t\t\t} else {\r\n\t\t\t\tnext.push(deferred)\r\n\t\t\t}\r\n\r\n\t\t\treturn deferred.promise\r\n\t\t}\r\n\r\n\t\tfunction finish(type) {\r\n\t\t\tstate = type || REJECTED\r\n\t\t\tnext.map(function (deferred) {\r\n\t\t\t\tif (state === RESOLVED) {\r\n\t\t\t\t\tdeferred.resolve(promiseValue)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdeferred.reject(promiseValue)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tfunction thennable(then, success, failure, notThennable) {\r\n\t\t\tif (((promiseValue != null && isObject(promiseValue)) ||\r\n\t\t\t\t\tisFunction(promiseValue)) && isFunction(then)) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\t// count protects against abuse calls from spec checker\r\n\t\t\t\t\tvar count = 0\r\n\t\t\t\t\tthen.call(promiseValue, function (value) {\r\n\t\t\t\t\t\tif (count++) return\r\n\t\t\t\t\t\tpromiseValue = value\r\n\t\t\t\t\t\tsuccess()\r\n\t\t\t\t\t}, function (value) {\r\n\t\t\t\t\t\tif (count++) return\r\n\t\t\t\t\t\tpromiseValue = value\r\n\t\t\t\t\t\tfailure()\r\n\t\t\t\t\t})\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.deferred.onerror(e)\r\n\t\t\t\t\tpromiseValue = e\r\n\t\t\t\t\tfailure()\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnotThennable()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction fire() {\r\n\t\t\t// check if it's a thenable\r\n\t\t\tvar then\r\n\t\t\ttry {\r\n\t\t\t\tthen = promiseValue && promiseValue.then\r\n\t\t\t} catch (e) {\r\n\t\t\t\tm.deferred.onerror(e)\r\n\t\t\t\tpromiseValue = e\r\n\t\t\t\tstate = REJECTING\r\n\t\t\t\treturn fire()\r\n\t\t\t}\r\n\r\n\t\t\tif (state === REJECTING) {\r\n\t\t\t\tm.deferred.onerror(promiseValue)\r\n\t\t\t}\r\n\r\n\t\t\tthennable(then, function () {\r\n\t\t\t\tstate = RESOLVING\r\n\t\t\t\tfire()\r\n\t\t\t}, function () {\r\n\t\t\t\tstate = REJECTING\r\n\t\t\t\tfire()\r\n\t\t\t}, function () {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (state === RESOLVING && isFunction(onSuccess)) {\r\n\t\t\t\t\t\tpromiseValue = onSuccess(promiseValue)\r\n\t\t\t\t\t} else if (state === REJECTING && isFunction(onFailure)) {\r\n\t\t\t\t\t\tpromiseValue = onFailure(promiseValue)\r\n\t\t\t\t\t\tstate = RESOLVING\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.deferred.onerror(e)\r\n\t\t\t\t\tpromiseValue = e\r\n\t\t\t\t\treturn finish()\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (promiseValue === self) {\r\n\t\t\t\t\tpromiseValue = TypeError()\r\n\t\t\t\t\tfinish()\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthennable(then, function () {\r\n\t\t\t\t\t\tfinish(RESOLVED)\r\n\t\t\t\t\t}, finish, function () {\r\n\t\t\t\t\t\tfinish(state === RESOLVING && RESOLVED)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tm.deferred.onerror = function (e) {\r\n\t\tif (type.call(e) === \"[object Error]\" &&\r\n\t\t\t\t!/ Error/.test(e.constructor.toString())) {\r\n\t\t\tpendingRequests = 0\r\n\t\t\tthrow e\r\n\t\t}\r\n\t}\r\n\r\n\tm.sync = function (args) {\r\n\t\tvar deferred = m.deferred()\r\n\t\tvar outstanding = args.length\r\n\t\tvar results = new Array(outstanding)\r\n\t\tvar method = \"resolve\"\r\n\r\n\t\tfunction synchronizer(pos, resolved) {\r\n\t\t\treturn function (value) {\r\n\t\t\t\tresults[pos] = value\r\n\t\t\t\tif (!resolved) method = \"reject\"\r\n\t\t\t\tif (--outstanding === 0) {\r\n\t\t\t\t\tdeferred.promise(results)\r\n\t\t\t\t\tdeferred[method](results)\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (args.length > 0) {\r\n\t\t\tforEach(args, function (arg, i) {\r\n\t\t\t\targ.then(synchronizer(i, true), synchronizer(i, false))\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\tdeferred.resolve([])\r\n\t\t}\r\n\r\n\t\treturn deferred.promise\r\n\t}\r\n\r\n\tfunction identity(value) { return value }\r\n\r\n\tfunction handleJsonp(options) {\r\n\t\tvar callbackKey = \"mithril_callback_\" +\r\n\t\t\tnew Date().getTime() + \"_\" +\r\n\t\t\t(Math.round(Math.random() * 1e16)).toString(36)\r\n\r\n\t\tvar script = $document.createElement(\"script\")\r\n\r\n\t\tglobal[callbackKey] = function (resp) {\r\n\t\t\tscript.parentNode.removeChild(script)\r\n\t\t\toptions.onload({\r\n\t\t\t\ttype: \"load\",\r\n\t\t\t\ttarget: {\r\n\t\t\t\t\tresponseText: resp\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tglobal[callbackKey] = undefined\r\n\t\t}\r\n\r\n\t\tscript.onerror = function () {\r\n\t\t\tscript.parentNode.removeChild(script)\r\n\r\n\t\t\toptions.onerror({\r\n\t\t\t\ttype: \"error\",\r\n\t\t\t\ttarget: {\r\n\t\t\t\t\tstatus: 500,\r\n\t\t\t\t\tresponseText: JSON.stringify({\r\n\t\t\t\t\t\terror: \"Error making jsonp request\"\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tglobal[callbackKey] = undefined\r\n\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\tscript.onload = function () {\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\tscript.src = options.url +\r\n\t\t\t(options.url.indexOf(\"?\") > 0 ? \"&\" : \"?\") +\r\n\t\t\t(options.callbackKey ? options.callbackKey : \"callback\") +\r\n\t\t\t\"=\" + callbackKey +\r\n\t\t\t\"&\" + buildQueryString(options.data || {})\r\n\r\n\t\t$document.body.appendChild(script)\r\n\t}\r\n\r\n\tfunction createXhr(options) {\r\n\t\tvar xhr = new global.XMLHttpRequest()\r\n\t\txhr.open(options.method, options.url, true, options.user,\r\n\t\t\toptions.password)\r\n\r\n\t\txhr.onreadystatechange = function () {\r\n\t\t\tif (xhr.readyState === 4) {\r\n\t\t\t\tif (xhr.status >= 200 && xhr.status < 300) {\r\n\t\t\t\t\toptions.onload({type: \"load\", target: xhr})\r\n\t\t\t\t} else {\r\n\t\t\t\t\toptions.onerror({type: \"error\", target: xhr})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (options.serialize === JSON.stringify &&\r\n\t\t\t\toptions.data &&\r\n\t\t\t\toptions.method !== \"GET\") {\r\n\t\t\txhr.setRequestHeader(\"Content-Type\",\r\n\t\t\t\t\"application/json; charset=utf-8\")\r\n\t\t}\r\n\r\n\t\tif (options.deserialize === JSON.parse) {\r\n\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\")\r\n\t\t}\r\n\r\n\t\tif (isFunction(options.config)) {\r\n\t\t\tvar maybeXhr = options.config(xhr, options)\r\n\t\t\tif (maybeXhr != null) xhr = maybeXhr\r\n\t\t}\r\n\r\n\t\tvar data = options.method === \"GET\" || !options.data ? \"\" : options.data\r\n\r\n\t\tif (data && !isString(data) && data.constructor !== global.FormData) {\r\n\t\t\tthrow new Error(\"Request data should be either be a string or \" +\r\n\t\t\t\t\"FormData. Check the `serialize` option in `m.request`\")\r\n\t\t}\r\n\r\n\t\txhr.send(data)\r\n\t\treturn xhr\r\n\t}\r\n\r\n\tfunction ajax(options) {\r\n\t\tif (options.dataType && options.dataType.toLowerCase() === \"jsonp\") {\r\n\t\t\treturn handleJsonp(options)\r\n\t\t} else {\r\n\t\t\treturn createXhr(options)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction bindData(options, data, serialize) {\r\n\t\tif (options.method === \"GET\" && options.dataType !== \"jsonp\") {\r\n\t\t\tvar prefix = options.url.indexOf(\"?\") < 0 ? \"?\" : \"&\"\r\n\t\t\tvar querystring = buildQueryString(data)\r\n\t\t\toptions.url += (querystring ? prefix + querystring : \"\")\r\n\t\t} else {\r\n\t\t\toptions.data = serialize(data)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction parameterizeUrl(url, data) {\r\n\t\tif (data) {\r\n\t\t\turl = url.replace(/:[a-z]\\w+/gi, function(token){\r\n\t\t\t\tvar key = token.slice(1)\r\n\t\t\t\tvar value = data[key]\r\n\t\t\t\tdelete data[key]\r\n\t\t\t\treturn value\r\n\t\t\t})\r\n\t\t}\r\n\t\treturn url\r\n\t}\r\n\r\n\tm.request = function (options) {\r\n\t\tif (options.background !== true) m.startComputation()\r\n\t\tvar deferred = new Deferred()\r\n\t\tvar isJSONP = options.dataType &&\r\n\t\t\toptions.dataType.toLowerCase() === \"jsonp\"\r\n\r\n\t\tvar serialize, deserialize, extract\r\n\r\n\t\tif (isJSONP) {\r\n\t\t\tserialize = options.serialize =\r\n\t\t\tdeserialize = options.deserialize = identity\r\n\r\n\t\t\textract = function (jsonp) { return jsonp.responseText }\r\n\t\t} else {\r\n\t\t\tserialize = options.serialize = options.serialize || JSON.stringify\r\n\r\n\t\t\tdeserialize = options.deserialize =\r\n\t\t\t\toptions.deserialize || JSON.parse\r\n\t\t\textract = options.extract || function (xhr) {\r\n\t\t\t\tif (xhr.responseText.length || deserialize !== JSON.parse) {\r\n\t\t\t\t\treturn xhr.responseText\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn null\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\toptions.method = (options.method || \"GET\").toUpperCase()\r\n\t\toptions.url = parameterizeUrl(options.url, options.data)\r\n\t\tbindData(options, options.data, serialize)\r\n\t\toptions.onload = options.onerror = function (ev) {\r\n\t\t\ttry {\r\n\t\t\t\tev = ev || event\r\n\t\t\t\tvar response = deserialize(extract(ev.target, options))\r\n\t\t\t\tif (ev.type === \"load\") {\r\n\t\t\t\t\tif (options.unwrapSuccess) {\r\n\t\t\t\t\t\tresponse = options.unwrapSuccess(response, ev.target)\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (isArray(response) && options.type) {\r\n\t\t\t\t\t\tforEach(response, function (res, i) {\r\n\t\t\t\t\t\t\tresponse[i] = new options.type(res)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else if (options.type) {\r\n\t\t\t\t\t\tresponse = new options.type(response)\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdeferred.resolve(response)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (options.unwrapError) {\r\n\t\t\t\t\t\tresponse = options.unwrapError(response, ev.target)\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdeferred.reject(response)\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\tdeferred.reject(e)\r\n\t\t\t} finally {\r\n\t\t\t\tif (options.background !== true) m.endComputation()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tajax(options)\r\n\t\tdeferred.promise = propify(deferred.promise, options.initialValue)\r\n\t\treturn deferred.promise\r\n\t}\r\n\r\n\treturn m\r\n})\r\n"],"sourceRoot":"/source/"}